<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>Canvas Draw</title>
<style>
body {
    margin: 0;
    background: #eee;
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    height: 100vh;
    overflow: hidden;
}

/* –í–µ—Ä—Ö–Ω—è –ø–∞–Ω–µ–ª—å */
.top-toolbar {
    background: #333;
    color: white;
    padding: 6px 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    flex-shrink: 0;
}

/* –û—Å–Ω–æ–≤–Ω–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç */
.main-content {
    display: flex;
    flex: 1;
    overflow: hidden;
}
/* –ú–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}

.modal-content {
    background: white;
    padding: 16px;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    max-width: 90vw;
    max-height: 90vh;
    overflow: auto;
}

.modal-canvas {
    border: 1px solid #999;
    background: white;
    max-width: 100%;
    max-height: 60vh; /* –æ–±–º–µ–∂—É—î–º–æ –≤–∏—Å–æ—Ç—É canvas */
    display: block;
}

.modal-buttons {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
}
/* –ë—ñ—á–Ω–∞ –ø–∞–Ω–µ–ª—å */
.side-toolbar {
    background: #333;
    display: flex;
    flex-direction: column;
    gap: 4px;
    padding: 8px;
    min-width: 70px;
    flex-shrink: 0; /* ‚Üê –Ω–µ —Å—Ç–∏—Å–∫–∞—Ç–∏! */
}

/* –Ü–∫–æ–Ω–∫–∏ –Ω–∞ –≤–µ—Ä—Ö–Ω—ñ–π –ø–∞–Ω–µ–ª—ñ */
.top-icon-btn {
    background: none;
    border: none;
    cursor: pointer;
    width: 40px;
    height: 40px;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 4px;
    border-radius: 4px;
}

.top-icon-btn:hover {
    background: #555;
}

.top-icon-btn img {
    width: 32px;
    height: 32px;
    display: block;
    image-rendering: -webkit-crisp-edges;
    image-rendering: crisp-edges;
}

.toolbar-button {
    padding: 6px;
    cursor: pointer;
    width: 60px;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    background: none;
    border: none;
    color: white;
}

.toolbar-button img {
    width: 48px;
    height: 48px;
    display: block;
    image-rendering: -webkit-crisp-edges;
    image-rendering: crisp-edges;
}

.toolbar-button.active {
    background: #ffcc00;
    border-radius: 4px;
}

/* === –í–ï–†–•–ù–Ø –ü–ê–ù–ï–õ–¨ (–æ–ø–µ—Ä–∞—Ü—ñ—ó) === */
.top-icon-btn {
    background: none;
    border: none;
    cursor: pointer;
    width: 40px;
    height: 40px;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 4px;
    border-radius: 4px;
}

.top-icon-btn:hover {
    background: #555;
}

.top-icon-btn img {
    width: 48px;
    height: 48px;
    display: block;
    image-rendering: -webkit-crisp-edges;
    image-rendering: crisp-edges;
}
/* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è canvas */
.canvas-container {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: auto;
    background: #ddd; /* —Ñ–æ–Ω –Ω–∞–≤–∫–æ–ª–æ canvas */
}

canvas {
    background: white;
    border: 1px solid #999;
    display: block;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
}
.selection-only {
    display: none; /* –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º –ø—Ä–∏—Ö–æ–≤–∞–Ω–æ */
}
</style>
</head>
<body>
<!-- –í–µ—Ä—Ö–Ω—è –ø–∞–Ω–µ–ª—å -->
<div class="top-toolbar">
    <input type="color" id="colorPicker" value="#000000">
   
	<button id="openBtn" class="top-icon-btn">
		<img src="images/open.png" alt="Open">
	</button>
	<button id="saveBtn" class="top-icon-btn">
		<img src="images/save.png" alt="Save">
	</button>
    <button onclick="undo()" class="top-icon-btn">
        <img src="images/undo.png" alt="Undo">
    </button>
    <button onclick="redo()" class="top-icon-btn">
        <img src="images/redo.png" alt="Redo">
    </button>

	<input type="file" id="fileInput" accept="image/*" style="display:none;">
    <div class="brush-controls" style="display: flex; align-items: center; gap: 6px; white-space: nowrap;">
      <img src="images/brush_w.png" alt="Brush size" width="32" height="32">
      <input type="range" id="brushSize" min="1" max="50" value="2" style="width:80px;">
      <span id="brushSizeLabel">2</span>
    </div>
    
    <div class="eraser-controls" style="display: flex; align-items: center; gap: 6px; white-space: nowrap;">
      <img src="images/eraser_w.png" alt="Eraser size" width="32" height="32">
      <input type="range" id="eraserSize" min="2" max="50" value="20" style="width:80px;">
      <span id="eraserSizeLabel">20</span>
    </div>

    <button id="rotateBtn" class="top-icon-btn selection-only">
        <img src="images/rotate.png" alt="Rotate">
    </button>
    <button id="pixelsBtn" class="top-icon-btn selection-only">
        <img src="images/pixels.png" alt="Pixels">
    </button>
    <button id="copyBtn" class="top-icon-btn selection-only" onclick="copySelection()">
        <img src="images/copy.png" alt="Copy">
    </button>
    <button id="pasteBtn" class="top-icon-btn selection-only" onclick="pasteSelection()">
        <img src="images/paste.png" alt="Paste">
    </button>
    <button id="deleteBtn" class="top-icon-btn selection-only" onclick="deleteSelection()">
        <img src="images/delete.png" alt="Delete">
    </button>
    <button id="vmirrorBtn" class="top-icon-btn selection-only">
      <img src="images/vmirror.png" alt="Vertical Mirror">
    </button>
    <button id="hmirrorBtn" class="top-icon-btn selection-only">
      <img src="images/hmirror.png" alt="Horizontal Mirror">
    </button>    

</div>

<!-- –û—Å–Ω–æ–≤–Ω–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç -->
<div class="main-content">
    <!-- –ë—ñ—á–Ω–∞ –ø–∞–Ω–µ–ª—å -->
	<div class="side-toolbar">
        <button id="brushBtn" class="toolbar-button active">
            <img src="images/brush.png" alt="–ü–µ–Ω–∑–µ–ª—å">
        </button>
        <button id="eraserBtn" class="toolbar-button">
            <img src="images/eraser.png" alt="–ì—É–º–∫–∞">
        </button>
        <button id="lineBtn" class="toolbar-button">
            <img src="images/line.png" alt="–õ—ñ–Ω—ñ—è">
        </button>
        <button id="rectBtn" class="toolbar-button">
            <img src="images/rect.png" alt="–ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫">
        </button>
        <button id="ellipseBtn" class="toolbar-button">
            <img src="images/ellipse.png" alt="–ï–ª—ñ–ø—Å">
        </button>
        <button id="selectBtn" class="toolbar-button">
            <img src="images/select.png" alt="–í–∏–¥—ñ–ª–µ–Ω–Ω—è">
        </button>
        <button id="fillBtn" class="toolbar-button">
            <img src="images/fill.png" alt="–ó–∞–ø–æ–≤–Ω–µ–Ω–Ω—è">
        </button>
        <button id="textBtn" class="toolbar-button">
			<img src="images/text.png" alt="–¢–µ–∫—Å—Ç">
		</button>
		<button id="eyedropperBtn" class="toolbar-button">
			<img src="images/eyedropper.png" alt="–ü—ñ–ø–µ—Ç–∫–∞">
		</button>
		<button id="clearBtn" class="toolbar-button" >
			<img src="images/clear.png" alt="Clear">
		</button>
    </div>

    <!-- Canvas -->
    <div class="canvas-container">
        <canvas id="canvas" width="900" height="600" draggable="false"></canvas>
    </div>
</div>

<div id="eraserCursor"></div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });

/* -------- STATE -------- */
let tool = 'brush';
let isDrawing = false;
let isSelecting = false;
let isDraggingLayer = false;

let startX = 0, startY = 0;

let selectionRect = null;
let floatingLayer = null;
let clipboardData = null;

let history = [];
let historyIndex = -1;

let dashOffset = 0;
let isDraggingFloating = false;
let dragOffsetX = 0;
let dragOffsetY = 0;
let currentShape = null; // {type: 'rect'|'ellipse', x,y,w,h, color}
let currentBrushPath = []; // [{x,y}, ...]
let isResizing = false;
let resizeHandle = null; // 'nw', 'ne', 'sw', 'se'
let originalClipboard = null; // –∑–±–µ—Ä—ñ–≥–∞—î–º–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª
let transformMode = 'scale'; // 'scale' –∞–±–æ 'rotate'
let isRotating = false;
let startAngle = 0;
let brushClickStart = null; // {x, y} –ø–µ—Ä—à–æ—ó —Ç–æ—á–∫–∏ –¥–ª—è –ª—ñ–Ω—ñ—ó
let wasDragged = false;     // —á–∏ –±—É–≤ —Ä—É—Ö –ø—ñ–¥ —á–∞—Å –Ω–∞—Ç–∏—Å–∫–∞–Ω–Ω—è
let eraserSize = 20; // –ì–ª–æ–±–∞–ª—å–Ω–∞ –∑–º—ñ–Ω–Ω–∞ –¥–ª—è —Ä–æ–∑–º—ñ—Ä—É –≥—É–º–∫–∏
let brushSize = 2;
const eraserCursor = document.getElementById('eraserCursor');
let lineStart = null; // {x, y} ‚Äî –ø–æ—Ç–æ—á–Ω–∞ –ø–æ—á–∞—Ç–∫–æ–≤–∞ —Ç–æ—á–∫–∞
let mousePos = { x: 0, y: 0 };
let textContent = '';
let textPosition = null;
let isEditingText = false;
let cursorVisible = true;
let cursorBlinkInterval = null;



/* -------- INIT -------- */
ctx.fillStyle = "#fff";
ctx.fillRect(0,0,canvas.width,canvas.height);
saveState();
animateAnts();

/* -------- TOOLS -------- */
['brush','rect','ellipse','select','fill','eraser','line','text','eyedropper'].forEach(t=>{
    if (document.getElementById(t+'Btn')) {
        document.getElementById(t+'Btn').onclick=()=>setTool(t);
    }
});
document.getElementById('rotateBtn').onclick = () => {
    const rotateBtnImg = document.getElementById('rotateBtn').querySelector('img');
    
    if (transformMode === 'scale') {
        transformMode = 'rotate';
        rotateBtnImg.src = 'images/scale.png'; // –ü–æ–∫–∞–∑—É—î–º–æ —ñ–∫–æ–Ω–∫—É "Scale"
        rotateBtnImg.alt = 'Scale';
    } else {
        transformMode = 'scale';
        rotateBtnImg.src = 'images/rotate.png'; // –ü–æ–∫–∞–∑—É—î–º–æ —ñ–∫–æ–Ω–∫—É "Rotate"
        rotateBtnImg.alt = 'Rotate';
    }
    render(); // –æ–Ω–æ–≤–∏—Ç–∏ –≤—ñ–¥–æ–±—Ä–∞–∂–µ–Ω–Ω—è –º–∞—Ä–∫–µ—Ä—ñ–≤
};
document.getElementById('clearBtn').onclick = clearCanvas;
// –û–Ω–æ–≤–ª—é—î–º–æ —Ä–æ–∑–º—ñ—Ä –ø—Ä–∏ –∑–º—ñ–Ω—ñ —Å–ª–∞–π–¥–µ—Ä–∞
document.getElementById('eraserSize').oninput = (e) => {
    eraserSize = parseInt(e.target.value);
    document.getElementById('eraserSizeLabel').textContent = eraserSize;
};
document.getElementById('brushSize').oninput = (e) => {
    brushSize = parseInt(e.target.value);
    document.getElementById('brushSizeLabel').textContent = brushSize;
};
// –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–µ –¥–∑–µ—Ä–∫–∞–ª–æ
document.getElementById('vmirrorBtn').onclick = () => {
  if (!floatingLayer) return;
  mirrorFloatingLayer(true, false);
};

// –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–µ –¥–∑–µ—Ä–∫–∞–ª–æ
document.getElementById('hmirrorBtn').onclick = () => {
  if (!floatingLayer) return;
  mirrorFloatingLayer(false, true);
};
// –í–∏–º–∏–∫–∞—î–º–æ drag-and-drop –¥–ª—è canvas
canvas.ondragstart = () => false;

function setTool(t){
  tool = t;
  document.querySelectorAll('.toolbar-button').forEach(b => b.classList.remove('active'));
  document.getElementById(t+'Btn').classList.add('active');
  canvas.style.cursor = (t === 'eyedropper') ? 'crosshair' : 'default'; // üëà
  // –°–∫–∏–¥–∞—î–º–æ —Å—Ç–∞–Ω–∏...
  selectionRect = null;
  floatingLayer = null;
  brushClickStart = null;
  lineStart = null;
  if (isEditingText) {
    finishTextEditing();
  }
  render();
  updateSelectionButtons();
  // –ü–æ–∫–∞–∑—É—î–º–æ/—Ö–æ–≤–∞—î–º–æ —Å–ª–∞–π–¥–µ—Ä–∏ —Ä–æ–∑–º—ñ—Ä—É
  const brushControls = document.querySelector('.brush-controls');
  const eraserControls = document.querySelector('.eraser-controls');
  if (brushControls && eraserControls) {
    brushControls.style.display = (tool === 'brush') ? 'flex' : 'none';
    eraserControls.style.display = (tool === 'eraser') ? 'flex' : 'none';
  }  
}

function clearCanvas() {
  if (confirm('–û—á–∏—Å—Ç–∏—Ç–∏ –≤—Å–µ –ø–æ–ª–æ—Ç–Ω–æ?')) {
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    selectionRect = null;
    floatingLayer = null;
    saveState(); // ‚Üê –¥–æ–¥–∞—î —á–∏—Å—Ç–∏–π —Å—Ç–∞–Ω –¥–æ —ñ—Å—Ç–æ—Ä—ñ—ó, –Ω–µ –≤–∏–¥–∞–ª—è—é—á–∏ –º–∏–Ω—É–ª–µ
    render();
    updateSelectionButtons();
  }
}

function updateSelectionButtons() {
    const hasSelection = selectionRect !== null || floatingLayer !== null;
    const buttons = document.querySelectorAll('.selection-only');
    
    buttons.forEach(btn => {
        btn.style.display = hasSelection ? 'flex' : 'none';
    });
}
/* -------- HISTORY -------- */
function saveState(){
    history=history.slice(0,historyIndex+1);
    history.push(ctx.getImageData(0,0,canvas.width,canvas.height));
    historyIndex++;
}
function undo(){
    if(historyIndex>0){
        historyIndex--;
        ctx.putImageData(history[historyIndex],0,0);
        selectionRect=null;
        floatingLayer=null;
    }
}
function redo(){
    if(historyIndex<history.length-1){
        historyIndex++;
        ctx.putImageData(history[historyIndex],0,0);
        selectionRect=null;
        floatingLayer=null;
    }
}
/* --------------- */

function floodFill(ctx, x, y, fillColorHex, tolerance = 32) {
    const canvas = ctx.canvas;
    const width = canvas.width;
    const height = canvas.height;

    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;

    // –ü–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è –∫–æ–ª—å–æ—Ä—É
    const hexToRgb = (hex) => {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return { r, g, b };
    };

    const getColor = (x, y) => {
        const i = (y * width + x) * 4;
        return {
            r: data[i],
            g: data[i + 1],
            b: data[i + 2],
            a: data[i + 3]
        };
    };

    const setColor = (x, y, color) => {
        const i = (y * width + x) * 4;
        data[i] = color.r;
        data[i + 1] = color.g;
        data[i + 2] = color.b;
        data[i + 3] = 255;
    };

    const targetColor = getColor(x, y);
    const replacementColor = hexToRgb(fillColorHex);

    // –Ø–∫—â–æ –∫–ª—ñ–∫–Ω—É–ª–∏ –Ω–∞ –∫–æ–Ω—Ç—É—Ä –∞–±–æ –ø—Ä–æ–∑–æ—Ä–∏–π –ø—ñ–∫—Å–µ–ª—å ‚Äî –Ω—ñ—á–æ–≥–æ –Ω–µ —Ä–æ–±–∏–º–æ
    if (targetColor.a < 255 || 
        (targetColor.r === replacementColor.r &&
         targetColor.g === replacementColor.g &&
         targetColor.b === replacementColor.b)) {
        return;
    }

    // –í—ñ–¥—Å—Ç–∞–Ω—å –º—ñ–∂ –∫–æ–ª—å–æ—Ä–∞–º–∏ (–µ–≤–∫–ª—ñ–¥–æ–≤–∞)
    const colorDistance = (c1, c2) => {
        const dr = c1.r - c2.r;
        const dg = c1.g - c2.g;
        const db = c1.b - c2.b;
        return Math.sqrt(dr * dr + dg * dg + db * db);
    };

    const visited = new Uint8Array(width * height); // –µ—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—à–µ –∑–∞ Set

    const stack = [{ x, y }];
    visited[y * width + x] = 1;

    while (stack.length > 0) {
        const { x, y } = stack.pop();
        setColor(x, y, replacementColor);

        const neighbors = [
            [x + 1, y],
            [x - 1, y],
            [x, y + 1],
            [x, y - 1]
        ];

        for (const [nx, ny] of neighbors) {
            if (nx < 0 || ny < 0 || nx >= width || ny >= height) continue;

            const idx = ny * width + nx;
            if (visited[idx]) continue;

            const neighborColor = getColor(nx, ny);
            if (neighborColor.a < 255) continue; // –Ω–µ –∑–∞–ª–∏–≤–∞—î–º–æ –ø—Ä–æ–∑–æ—Ä—ñ

            // –Ø–∫—â–æ –∫–æ–ª—ñ—Ä **–¥—É–∂–µ –≤—ñ–¥—Ä—ñ–∑–Ω—è—î—Ç—å—Å—è** ‚Äî —Ü–µ "–±–∞—Ä‚Äô—î—Ä" (–∫–æ–Ω—Ç—É—Ä)
            if (colorDistance(neighborColor, targetColor) > tolerance) {
                continue;
            }

            visited[idx] = 1;
            stack.push({ x: nx, y: ny });
        }
    }

    ctx.putImageData(imageData, 0, 0);
}

function rgbToHex(r, g, b) {
  return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
}

/* -------- CANVAS EVENTS -------- */
canvas.onmousedown = e => {
   const x = e.offsetX;
   const y = e.offsetY;

   // üîç –ü—ñ–ø–µ—Ç–∫–∞: –æ—Ç—Ä–∏–º–∞—Ç–∏ –∫–æ–ª—ñ—Ä –∑ canvas
   if (tool === 'eyedropper') {
    const pixel = ctx.getImageData(x, y, 1, 1).data;
    const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);
    document.getElementById('colorPicker').value = hex;   
    return;
   }
   // üëâ —è–∫—â–æ —î floating layer —ñ –∫–ª—ñ–∫ –ø–æ –Ω—å–æ–º—É (–∞–ª–µ –Ω–µ –ø–æ –º–∞—Ä–∫–µ—Ä—É!)
   if (floatingLayer &&
        x >= floatingLayer.x &&
        x <= floatingLayer.x + floatingLayer.w &&
        y >= floatingLayer.y &&
        y <= floatingLayer.y + floatingLayer.h
    ) {
        // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞, —á–∏ –Ω–µ –∫–ª—ñ–∫ –ø–æ –º–∞—Ä–∫–µ—Ä—É (–≤–∏–∫–æ–Ω–∞—î—Ç—å—Å—è –¥–∞–ª—ñ)
    }
	if (tool === 'fill') {
		const x = e.offsetX;
		const y = e.offsetY;
		// –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ—Ç–æ—á–Ω–∏–π —Å—Ç–∞–Ω –ø–µ—Ä–µ–¥ –∑–∞–ª–∏–≤–∫–æ—é
		renderBaseOnly(); // –≤—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –±–µ–∑ overlay
		floodFill(ctx, x, y, colorPicker.value, 64);
		saveState();
		render(); // –ø–æ–Ω–æ–≤–∏—Ç–∏ (—Ö–æ—á–∞ overlay –ø–æ—Ä–æ–∂–Ω—ñ–π)
		return;
	}
	
    if (tool === 'text') {
        // –Ø–∫—â–æ –≤–∂–µ —Ä–µ–¥–∞–≥—É—î–º–æ —Ç–µ–∫—Å—Ç ‚Äî –∑–∞–≤–µ—Ä—à—É—î–º–æ
        if (isEditingText) {
            finishTextEditing();
        }
        
        // –ü–æ—á–∏–Ω–∞—î–º–æ –Ω–æ–≤–∏–π —Ç–µ–∫—Å—Ç
        textPosition = { x, y };
        textContent = '';
        isEditingText = true;
        startCursorBlink();
        render();
        return;
    }
	
    // üîπ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –º–∞—Ä–∫–µ—Ä—ñ–≤
    if (tool === 'select' && selectionRect && floatingLayer && transformMode === 'scale') {
        const handleSize = 8;
        const hx = x;
        const hy = y;
        const { x: sx, y: sy, w, h } = selectionRect;
        const tolerance = handleSize;

        if (Math.abs(hx - sx) <= tolerance && Math.abs(hy - sy) <= tolerance) {
            isResizing = true;
            resizeHandle = 'nw';
            startX = hx;
            startY = hy;
            return;
        }
        if (Math.abs(hx - (sx + w)) <= tolerance && Math.abs(hy - sy) <= tolerance) {
            isResizing = true;
            resizeHandle = 'ne';
            startX = hx;
            startY = hy;
            return;
        }
        if (Math.abs(hx - sx) <= tolerance && Math.abs(hy - (sy + h)) <= tolerance) {
            isResizing = true;
            resizeHandle = 'sw';
            startX = hx;
            startY = hy;
            return;
        }
        if (Math.abs(hx - (sx + w)) <= tolerance && Math.abs(hy - (sy + h)) <= tolerance) {
            isResizing = true;
            resizeHandle = 'se';
            startX = hx;
            startY = hy;
            return;
        }
    }

	// –û–±—Ä–æ–±–∫–∞ –æ–±–µ—Ä—Ç–∞–Ω–Ω—è (—É —Ä–µ–∂–∏–º—ñ rotate)
	if (tool === 'select' && selectionRect && floatingLayer && transformMode === 'rotate') {
		const handleRadius = 8;
		const hx = e.offsetX;
		const hy = e.offsetY;
		const { x, y, w, h } = selectionRect;

		const corners = [
			{ x: x,           y: y           }, // nw
			{ x: x + w,       y: y           }, // ne
			{ x: x,           y: y + h       }, // sw
			{ x: x + w,       y: y + h       }  // se
		];

		for (const corner of corners) {
			const dx = hx - corner.x;
			const dy = hy - corner.y;
			if (Math.sqrt(dx * dx + dy * dy) <= handleRadius) {
				// –ö–ª—ñ–∫ –ø–æ –º–∞—Ä–∫–µ—Ä—É ‚Üí –ø–æ—á–∞—Ç–∏ –æ–±–µ—Ä—Ç–∞–Ω–Ω—è
				isRotating = true;
				const centerX = x + w / 2;
				const centerY = y + h / 2;
				const mouseAngle = Math.atan2(hy - centerY, hx - centerX);
				startAngle = mouseAngle - floatingLayer.rotation;
				return;
			}
		}
	}
    // üëâ —è–∫—â–æ –∫–ª—ñ–∫ –ø–æ —Ç—ñ–ª—É floating layer (–∞–ª–µ –Ω–µ –ø–æ –º–∞—Ä–∫–µ—Ä—É)
    if (floatingLayer &&
        x >= floatingLayer.x &&
        x <= floatingLayer.x + floatingLayer.w &&
        y >= floatingLayer.y &&
        y <= floatingLayer.y + floatingLayer.h
    ) {
        isDraggingFloating = true;
        dragOffsetX = x - floatingLayer.x;
        dragOffsetY = y - floatingLayer.y;
        return;
    }

    startX = x;
    startY = y;

    if (tool === 'brush') {
        isDrawing = true;
        wasDragged = false; // —Å–∫–∏–¥–∞—î–º–æ –ø—Ä–∞–ø–æ—Ä–µ—Ü—å —Ä—É—Ö—É
        startX = x;
        startY = y;
    
        // –Ø–∫—â–æ —Ä–∞–Ω—ñ—à–µ –±—É–ª–∞ –ø–µ—Ä—à–∞ —Ç–æ—á–∫–∞ ‚Äî —ñ–≥–Ω–æ—Ä—É—î–º–æ (–º–∞—î –æ–±—Ä–æ–±–∏—Ç–∏—Å—å –ø—Ä–∏ mouseup)
        // –ü–æ—á–∞—Ç–æ–∫ –Ω–æ–≤–æ–≥–æ —à–ª—è—Ö—É
        currentBrushPath = [{ x: startX, y: startY }];
    }
    
    if (tool === 'eraser') {
        isDrawing = true;
        wasDragged = false;
        startX = x;
        startY = y;
        currentBrushPath = [{ x, y }];
    
        // –ú–∞–ª—é—î–º–æ –±—ñ–ª–∏–π
        ctx.save();
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(x, y, eraserSize / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    
        // –ü–æ–∫–∞–∑—É—î–º–æ HTML-–∫—É—Ä—Å–æ—Ä
        eraserCursor.style.width = eraserSize + 'px';
        eraserCursor.style.height = eraserSize + 'px';
        eraserCursor.style.left = (canvas.offsetLeft + x) + 'px';
        eraserCursor.style.top = (canvas.offsetTop + y) + 'px';
        eraserCursor.style.display = 'block';
    }

	if(tool==='rect' || tool==='ellipse'){
		isDrawing=true;
		currentShape={type: tool, x:startX, y:startY, w:0, h:0, color: colorPicker.value};
	}

    if (tool === 'select') {
        isSelecting = true;
        selectionRect = { x: startX, y: startY, w: 0, h: 0 };
        updateSelectionButtons();
    }
    
    if (tool === 'line') {
        if (lineStart === null) {
            lineStart = { x, y };
        }
        render();
        return;
    }    
};


canvas.onmousemove = e => {
    mousePos.x = e.offsetX;
    mousePos.y = e.offsetY;
    const x = e.offsetX;
    const y = e.offsetY;

    if (isResizing && floatingLayer) {
		const dx = e.offsetX - startX;
		const dy = e.offsetY - startY;

		const newX = floatingLayer.x;
		const newY = floatingLayer.y;
		let newW = floatingLayer.w;
		let newH = floatingLayer.h;

    switch (resizeHandle) {
        case 'nw':
            newW -= dx;
            newH -= dy;
            floatingLayer.x += dx;
            floatingLayer.y += dy;
            break;
        case 'ne':
            newW += dx;
            newH -= dy;
            floatingLayer.y += dy;
            break;
        case 'sw':
            newW -= dx;
            newH += dy;
            floatingLayer.x += dx;
            break;
        case 'se':
            newW += dx;
            newH += dy;
            break;
		}

		// –ó–∞–±–æ—Ä–æ–Ω—è—î–º–æ –Ω–µ–≥–∞—Ç–∏–≤–Ω–∏–π —Ä–æ–∑–º—ñ—Ä
		if (newW < 5) newW = 5;
		if (newH < 5) newH = 5;

		floatingLayer.w = newW;
		floatingLayer.h = newH;
		selectionRect.x = floatingLayer.x;
		selectionRect.y = floatingLayer.y;
		selectionRect.w = floatingLayer.w;
		selectionRect.h = floatingLayer.h;

		render();
		startX = e.offsetX;
		startY = e.offsetY;
		return;
	}

	if (isRotating && floatingLayer) {
		const hx = e.offsetX;
		const hy = e.offsetY;
		const { x, y, w, h } = selectionRect;
		const centerX = x + w / 2;
		const centerY = y + h / 2;

		const mouseAngle = Math.atan2(hy - centerY, hx - centerX);
		floatingLayer.rotation = mouseAngle - startAngle;

		// –ù–æ—Ä–º–∞–ª—ñ–∑–∞—Ü—ñ—è –∫—É—Ç–∞ –Ω–µ –æ–±–æ–≤‚Äô—è–∑–∫–æ–≤–∞, –∞–ª–µ –º–æ–∂–Ω–∞
		// floatingLayer.rotation = ((floatingLayer.rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);

		render();
		return;
	}

    if (isDraggingFloating) {
        floatingLayer.x = x - dragOffsetX;
        floatingLayer.y = y - dragOffsetY;
        selectionRect.x = floatingLayer.x;
        selectionRect.y = floatingLayer.y;
        render();
        return;
    }


    if (tool === 'brush'  && isDrawing) {
        wasDragged = true;
        currentBrushPath.push({ x: e.offsetX, y: e.offsetY });
        render(); // –æ–Ω–æ–≤–ª—é—î –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π –ø–µ—Ä–µ–≥–ª—è–¥
    }


    if (tool === 'eraser' && isDrawing) {
        const currX = e.offsetX;
        const currY = e.offsetY;
    
        // –ú–∞–ª—é—î–º–æ –±—ñ–ª–∏–π –Ω–∞ canvas
        ctx.save();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = eraserSize;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        const last = currentBrushPath[currentBrushPath.length - 1];
        ctx.moveTo(last.x, last.y);
        ctx.lineTo(currX, currY);
        ctx.stroke();
        ctx.restore();
    
        wasDragged = true;
        currentBrushPath.push({ x: currX, y: currY });
    
        // –û–Ω–æ–≤–ª—é—î–º–æ HTML-–∫—É—Ä—Å–æ—Ä
        eraserCursor.style.left = (canvas.offsetLeft + currX) + 'px';
        eraserCursor.style.top = (canvas.offsetTop + currY) + 'px';
    }
    
           
    
	if(isDrawing && (tool==='rect'||tool==='ellipse')){
		currentShape.w = x - startX;
		currentShape.h = y - startY;
		render();
	}


    if (tool === 'select' && isSelecting) {
        selectionRect.w = x - startX;
        selectionRect.h = y - startY;
        render();
    }
    

};


canvas.onmouseup = () => {
    if (isDraggingFloating) {
        isDraggingFloating = false;
        return;
    }
    
    if (tool === 'line' && lineStart !== null) {
        const endX = mousePos.x;
        const endY = mousePos.y;
        
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(lineStart.x, lineStart.y);
        ctx.lineTo(endX, endY);
        ctx.strokeStyle = colorPicker.value;
        ctx.lineWidth = brushSize;
        ctx.stroke();
        ctx.restore();
        
        saveState();
        lineStart = { x: endX, y: endY };
        render();
        return;
    }
    if (tool === 'eraser' && isDrawing) {
        isDrawing = false;
        saveState();
        currentBrushPath = [];
        eraserCursor.style.display = 'none'; // üëà —Ö–æ–≤–∞—î–º–æ
    }
    
    if (tool === 'brush' && isDrawing) {
        isDrawing = false;
    

         // üëâ –ü–µ–Ω–∑–µ–ª—å: –∑–∞–ª–∏—à–∞—î–º–æ —è–∫ —î (–∞–ª–µ —Ç–µ–∂ –º–∞—î —Ñ—ñ–∫—Å—É–≤–∞—Ç–∏ –∑–º—ñ–Ω–∏)
         ctx.save();
         ctx.strokeStyle = colorPicker.value;
         ctx.lineWidth = brushSize;
         ctx.lineCap = 'round';
         ctx.lineJoin = 'round';
         ctx.beginPath();
         ctx.moveTo(currentBrushPath[0].x, currentBrushPath[0].y);
         for (let i = 1; i < currentBrushPath.length; i++) {
                ctx.lineTo(currentBrushPath[i].x, currentBrushPath[i].y);
         }
         ctx.stroke();
         ctx.restore();
   
    
        saveState(); // üîë –û–ë–û–í‚Äô–Ø–ó–ö–û–í–û!
        currentBrushPath = []; // üîë –û—á–∏—Å—Ç–∏—Ç–∏ ‚Äî —â–æ–± –∫—É—Ä—Å–æ—Ä –∑–Ω–∏–∫
        if (tool !== 'brush') brushClickStart = null;
    }

	if(isDrawing && (tool==='rect'||tool==='ellipse')){
		isDrawing=false;
		drawShape(currentShape, true); // true = commit to bitmap
		currentShape=null;
		saveState();
	}


    if (tool === 'select' && isSelecting) {
        isSelecting = false;
        normalizeSelection();
        render();
    }
    if (isResizing) {
		isResizing = false;
		resizeHandle = null;
		// –ù–ï –∑–±–µ—Ä—ñ–≥–∞—î–º–æ –≤ —ñ—Å—Ç–æ—Ä—ñ—é ‚Äî —Ü–µ —â–µ floating state
		return;
	}
	if (isRotating) {
		isRotating = false;
		return;
	}
};

canvas.ondblclick = () => {
    if (tool === 'line') {
        lineStart = null;
        render();
    } else {
        commitFloatingLayer();
    }
    brushClickStart = null;
};

// –û–±—Ä–æ–±–∫–∞ –∫–ª–∞–≤—ñ–∞—Ç—É—Ä–∏ –¥–ª—è —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —Ä–µ–∂–∏–º—É
window.addEventListener('keydown', (e) => {
    if (!isEditingText) return;

    e.preventDefault(); // –∑–∞–ø–æ–±—ñ–≥–∞—î –ø—Ä–æ–∫—Ä—É—Ç—Ü—ñ —Å—Ç–æ—Ä—ñ–Ω–∫–∏

    if (e.key === 'Enter') {
        finishTextEditing();
    } else if (e.key === 'Backspace') {
        textContent = textContent.slice(0, -1);
        render();
    } else if (e.key.length === 1) {
        textContent += e.key;
        render();
    }
});

function startCursorBlink() {
    cursorVisible = true;
    if (cursorBlinkInterval) clearInterval(cursorBlinkInterval);
    cursorBlinkInterval = setInterval(() => {
        cursorVisible = !cursorVisible;
        render();
    }, 500);
}

function finishTextEditing() {
    if (textContent.trim() !== '') {
        // üëâ –°–ø–æ—á–∞—Ç–∫—É –≤—ñ–¥–Ω–æ–≤–ª—é—î–º–æ canvas –±–µ–∑ –∫—É—Ä—Å–æ—Ä–∞
        renderBaseOnly(); // —Ü—è —Ñ—É–Ω–∫—Ü—ñ—è –≤–∂–µ —î —É –≤–∞—Å
        
        // üëâ –¢–µ–ø–µ—Ä –º–∞–ª—é—î–º–æ –¢–Ü–õ–¨–ö–ò —Ç–µ–∫—Å—Ç
        ctx.save();
        ctx.fillStyle = colorPicker.value;
        ctx.font = `${brushSize * 12}px Arial`;
        ctx.fillText(textContent, textPosition.x, textPosition.y);
        ctx.restore();
        
        saveState();
    }
    
    // –°–∫–∏–¥–∞—î–º–æ —Å—Ç–∞–Ω
    isEditingText = false;
    textContent = '';
    textPosition = null;
    if (cursorBlinkInterval) {
        clearInterval(cursorBlinkInterval);
        cursorBlinkInterval = null;
    }
    render(); // –æ–Ω–æ–≤–∏—Ç–∏ (–±–µ–∑ –∫—É—Ä—Å–æ—Ä–∞)
}



function commitFloatingLayer() {
    if (!floatingLayer) return;

    // –¢–∏–º—á–∞—Å–æ–≤–∏–π canvas –¥–ª—è —Ä–µ–Ω–¥–µ—Ä—É –æ–±–µ—Ä–Ω—É—Ç–æ–≥–æ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = floatingLayer.original.width;
    tempCanvas.height = floatingLayer.original.height;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.putImageData(floatingLayer.original, 0, 0);

    // –°—Ç–≤–æ—Ä—é—î–º–æ canvas –¥–ª—è –æ—Å—Ç–∞—Ç–æ—á–Ω–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É (–∑–≥—ñ–¥–Ω–æ –∑ selectionRect)
    const finalCanvas = document.createElement('canvas');
    finalCanvas.width = canvas.width;
    finalCanvas.height = canvas.height;
    const finalCtx = finalCanvas.getContext('2d');

    // –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –æ—Å–Ω–æ–≤–Ω–∏–π —Ñ–æ–Ω
    if (historyIndex >= 0) {
        finalCtx.putImageData(history[historyIndex], 0, 0);
    }

    // –ú–∞–ª—é—î–º–æ –æ–±–µ—Ä–Ω—É—Ç–∏–π —Ñ—Ä–∞–≥–º–µ–Ω—Ç
    const { x, y, w, h, rotation } = floatingLayer;
    const centerX = x + w / 2;
    const centerY = y + h / 2;

    finalCtx.save();
    finalCtx.translate(centerX, centerY);
    finalCtx.rotate(rotation);
    finalCtx.drawImage(tempCanvas, -w / 2, -h / 2, w, h);
    finalCtx.restore();

    // –û—á–∏—â–∞—î–º–æ –æ—Å–Ω–æ–≤–Ω–∏–π canvas —ñ –∑–±–µ—Ä—ñ–≥–∞—î–º–æ
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(finalCanvas, 0, 0);

    floatingLayer = null;
    selectionRect = null;
    saveState();
    render();
    updateSelectionButtons();
}



function renderBaseOnly() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (historyIndex >= 0) {
        ctx.putImageData(history[historyIndex], 0, 0);
    }
}


/* -------- SELECTION -------- */
function normalizeSelection(){
    if(!selectionRect)return;
    if(selectionRect.w<0){selectionRect.x+=selectionRect.w;selectionRect.w*=-1;}
    if(selectionRect.h<0){selectionRect.y+=selectionRect.h;selectionRect.h*=-1;}
    if(selectionRect.w<5||selectionRect.h<5) selectionRect=null;
    updateSelectionButtons();
}

/* -------- COPY / PASTE -------- */
function copySelection() {
    if (!selectionRect || historyIndex < 0) return;

    const src = history[historyIndex];
    const { x: sx, y: sy, w, h } = selectionRect;

    // –°—Ç–≤–æ—Ä—é—î–º–æ ImageData –¥–ª—è –±—É—Ñ–µ—Ä–∞
    clipboardData = new ImageData(w, h);

    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            const srcIndex = ((sy + y) * src.width + (sx + x)) * 4;
            const dstIndex = (y * w + x) * 4;

            const r = src.data[srcIndex];
            const g = src.data[srcIndex + 1];
            const b = src.data[srcIndex + 2];
            const a = src.data[srcIndex + 3];

            // –ö–æ–ø—ñ—é—î–º–æ –ø—ñ–∫—Å–µ–ª—å
            clipboardData.data[dstIndex]     = r;
            clipboardData.data[dstIndex + 1] = g;
            clipboardData.data[dstIndex + 2] = b;
            clipboardData.data[dstIndex + 3] = a;

            // –Ø–∫—â–æ –ø—ñ–∫—Å–µ–ª—å ‚Äî –±—ñ–ª–∏–π (—ñ –Ω–µ –ø—Ä–æ–∑–æ—Ä–∏–π), —Ä–æ–±–∏–º–æ –π–æ–≥–æ –ø—Ä–æ–∑–æ—Ä–∏–º
            if (r === 255 && g === 255 && b === 255 && a === 255) {
                clipboardData.data[dstIndex + 3] = 0; // Œ± = 0 ‚Üí –ø—Ä–æ–∑–æ—Ä–∏–π
            }
        }
    }
	updateSelectionButtons();
}

function pasteSelection(){
    if (!clipboardData) return;
    originalClipboard = clipboardData;
    floatingLayer = {
        x: 20,
        y: 20,
        w: clipboardData.width,
        h: clipboardData.height,
        original: clipboardData,
        rotation: 0 // —É —Ä–∞–¥—ñ–∞–Ω–∞—Ö
    };
    selectionRect = { x: 20, y: 20, w: clipboardData.width, h: clipboardData.height };
    render();
	updateSelectionButtons();
}


function deleteSelection() {
    // –í–∏–ø–∞–¥–æ–∫ 1: —î floatingLayer (–≤—Å—Ç–∞–≤–ª–µ–Ω–∏–π —Ñ—Ä–∞–≥–º–µ–Ω—Ç) ‚Üí –≤–∏–¥–∞–ª—è—î–º–æ –π–æ–≥–æ
    if (floatingLayer) {
        floatingLayer = null;
        selectionRect = null;
        render();
        return;
    }

    // –í–∏–ø–∞–¥–æ–∫ 2: —î –≤–∏–¥—ñ–ª–µ–Ω–∞ –æ–±–ª–∞—Å—Ç—å (selectionRect) ‚Üí –∑–∞–ª–∏–≤–∞—î–º–æ —ó—ó –∫–æ–ª—å–æ—Ä–æ–º —Ç–ª–∞
    if (selectionRect) {
        // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Å—Ç–∞–Ω –ø–µ—Ä–µ–¥ –∑–º—ñ–Ω–æ—é
        renderBaseOnly(); // –≤—ñ–¥–Ω–æ–≤–ª—é—î–º–æ canvas –±–µ–∑ overlay

        // –ö–æ–ª—ñ—Ä —Ç–ª–∞ (—É –≤–∞—à–æ–º—É –≤–∏–ø–∞–¥–∫—É ‚Äî –±—ñ–ª–∏–π, —è–∫ –ø—Ä–∏ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó)
        const bgColor = "#ffffff";

        // –°—Ç–≤–æ—Ä—é—î–º–æ —Ç–∏–º—á–∞—Å–æ–≤–∏–π ImageData –∑ –∫–æ–ª—å–æ—Ä–æ–º —Ç–ª–∞
        const { x, y, w, h } = selectionRect;
        const imageData = ctx.createImageData(w, h);
        const data = imageData.data;
        const bgR = 255, bgG = 255, bgB = 255, bgA = 255;

        for (let i = 0; i < data.length; i += 4) {
            data[i] = bgR;     // R
            data[i + 1] = bgG; // G
            data[i + 2] = bgB; // B
            data[i + 3] = bgA; // A
        }

        // –ù–∞–∫–ª–∞–¥–∞—î–º–æ "—á–∏—Å—Ç–∏–π" –±–ª–æ–∫ –Ω–∞ canvas
        ctx.putImageData(imageData, x, y);

        // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –≤ —ñ—Å—Ç–æ—Ä—ñ—é
        saveState();

        // –°–∫–∏–¥–∞—î–º–æ –≤–∏–¥—ñ–ª–µ–Ω–Ω—è
        selectionRect = null;
        render(); // –æ–Ω–æ–≤–∏—Ç–∏ (–±–µ–∑ selection overlay)
    }
	updateSelectionButtons();
}

//
function drawShape(shape, commit=false){
    if(!shape) return;

    if(!commit){
        ctx.save();
    }

    if(shape.type==='rect'){
        ctx.fillStyle=shape.color;
        ctx.fillRect(shape.x, shape.y, shape.w, shape.h);
        ctx.strokeStyle='#000';
        ctx.strokeRect(shape.x, shape.y, shape.w, shape.h);
    }else if(shape.type==='ellipse'){
        ctx.beginPath();
        ctx.ellipse(shape.x+shape.w/2, shape.y+shape.h/2, Math.abs(shape.w/2), Math.abs(shape.h/2),0,0,2*Math.PI);
        ctx.fillStyle=shape.color;
        ctx.fill();
        ctx.strokeStyle='#000';
        ctx.stroke();
    }

    if(!commit){
        ctx.restore();
    }
}

/* -------- RENDER -------- */
function render(){
    // üîë –ù–µ –≤—ñ–¥–Ω–æ–≤–ª—é—î–º–æ canvas –∑ —ñ—Å—Ç–æ—Ä—ñ—ó –ø—ñ–¥ —á–∞—Å –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –º–∞–ª—é–≤–∞–Ω–Ω—è –ø–µ–Ω–∑–ª–µ–º –∞–±–æ –≥—É–º–∫–æ—é
    if ((tool === 'brush' || tool === 'eraser') && isDrawing) {
        // –õ–∏—à–µ –æ–Ω–æ–≤–ª—é—î–º–æ overlay: –∫—É—Ä—Å–æ—Ä, floating layer —Ç–æ—â–æ
    } else {
        // –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –æ—Å–Ω–æ–≤–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –∑ —ñ—Å—Ç–æ—Ä—ñ—ó
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (historyIndex >= 0) {
            ctx.putImageData(history[historyIndex], 0, 0);
        }
    }

    // –ú–∞–ª—é—î–º–æ floatingLayer –∑ –æ–±–µ—Ä—Ç–∞–Ω–Ω—è–º
    if (floatingLayer) {
        const { x, y, w, h, original, rotation } = floatingLayer;
        const centerX = x + w / 2;
        const centerY = y + h / 2;

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = original.width;
        tempCanvas.height = original.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(original, 0, 0);

        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate(rotation);
        ctx.drawImage(tempCanvas, -w / 2, -h / 2, w, h);
        ctx.restore();
    }

    // –ú–∞–ª—é—î–º–æ —Ç–∏–º—á–∞—Å–æ–≤—ñ —Ñ—ñ–≥—É—Ä–∏ (–ø—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫, –µ–ª—ñ–ø—Å)
    if (currentShape) {
        drawShape(currentShape, false);
    }

    // üëÅÔ∏è –ú–∞–ª—é—î–º–æ –ö–£–†–°–û–† –≥—É–º–∫–∏ –∞–±–æ —Å–ª—ñ–¥ –ø–µ–Ω–∑–ª—è (—Ç—ñ–ª—å–∫–∏ overlay!)
    if (currentBrushPath.length > 0) {
        if (tool === 'eraser' && isDrawing) {
        } else if (tool === 'brush' && isDrawing) {
            // –ü–æ–∫–∞–∑—É—î–º–æ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π –ø–µ—Ä–µ–≥–ª—è–¥ –ø–µ–Ω–∑–ª—è
            ctx.save();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = colorPicker.value;
            ctx.lineWidth = brushSize;
            ctx.beginPath();
            ctx.moveTo(currentBrushPath[0].x, currentBrushPath[0].y);
            for (let i = 1; i < currentBrushPath.length; i++) {
                ctx.lineTo(currentBrushPath[i].x, currentBrushPath[i].y);
            }
            ctx.stroke();
            ctx.restore();
        }
    }
    // –¢–∏–º—á–∞—Å–æ–≤–∞ –ª—ñ–Ω—ñ—è
    if (tool === 'line' && lineStart !== null) {
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(lineStart.x, lineStart.y);
        ctx.lineTo(mousePos.x, mousePos.y);
        ctx.strokeStyle = colorPicker.value;
        ctx.lineWidth = brushSize;
        ctx.globalAlpha = 0.6;
        ctx.stroke();
        ctx.restore();
    }
    
    // –¢–µ–∫—Å—Ç–æ–≤–∏–π –∫—É—Ä—Å–æ—Ä
    if (isEditingText && textPosition) {
        ctx.save();
        ctx.fillStyle = colorPicker.value;
        ctx.font = `${brushSize * 12}px Arial`;
        
        // –ú–∞–ª—é—î–º–æ —Ç–µ–∫—Å—Ç
        ctx.fillText(textContent, textPosition.x, textPosition.y);
        
        // –ú–∞–ª—é—î–º–æ –º–∏–≥–∞—é—á–∏–π –∫—É—Ä—Å–æ—Ä
        if (cursorVisible) {
            const textWidth = ctx.measureText(textContent).width;
            const cursorX = textPosition.x + textWidth;
            const cursorY = textPosition.y;
            const cursorHeight = brushSize * 12;
            
            ctx.strokeStyle = colorPicker.value;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cursorX, cursorY - cursorHeight + 4);
            ctx.lineTo(cursorX, cursorY + 4);
            ctx.stroke();
        }
        ctx.restore();
    }    
    
    
    // –ú–∞–ª—é—î–º–æ —Ä–∞–º–∫—É –≤–∏–¥—ñ–ª–µ–Ω–Ω—è ("–º—É—Ä–∞—à–∫–∏")
    drawSelection();
}


function drawSelection(){
    if (!selectionRect) return;
    const { x, y, w, h } = selectionRect;

    ctx.save();
    // –ü—É–Ω–∫—Ç–∏—Ä–Ω–∞ —Ä–∞–º–∫–∞
    ctx.setLineDash([6, 4]);
    ctx.lineDashOffset = -dashOffset;
    ctx.strokeStyle = "#000";
    ctx.strokeRect(x, y, w, h);

    // –ú–∞–ª—é—î–º–æ –º–∞—Ä–∫–µ—Ä–∏ –∑–∞–ª–µ–∂–Ω–æ –≤—ñ–¥ —Ä–µ–∂–∏–º—É
    const corners = [
        { x: x,           y: y           }, // nw
        { x: x + w,       y: y           }, // ne
        { x: x,           y: y + h       }, // sw
        { x: x + w,       y: y + h       }  // se
    ];

    if (transformMode === 'scale') {
        // –ë–ª–∞–∫–∏—Ç–Ω—ñ –∫–≤–∞–¥—Ä–∞—Ç–∏
        const size = 8;
        ctx.fillStyle = "#00aaff";
        corners.forEach(pt => {
            ctx.fillRect(pt.x - size / 2, pt.y - size / 2, size, size);
        });
    } else if (transformMode === 'rotate') {
        // –ß–µ—Ä–≤–æ–Ω—ñ –∫–æ–ª–∞
        const radius = 5;
        ctx.fillStyle = "#ff0000";
        corners.forEach(pt => {
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, radius, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    ctx.restore();
}

/* -------- ANTS -------- */
function animateAnts(){
    dashOffset++;
    render();
    requestAnimationFrame(animateAnts);
}
// ------- PIXEL EDITOR -------
document.getElementById('pixelsBtn').onclick = showPixelEditor;

function showPixelEditor() {
    if (!selectionRect || historyIndex < 0) {
        alert("–°–ø–æ—á–∞—Ç–∫—É –≤–∏–¥—ñ–ª—ñ—Ç—å —Ñ—Ä–∞–≥–º–µ–Ω—Ç!");
        return;
    }

    normalizeSelection();
    if (!selectionRect || selectionRect.w < 1 || selectionRect.h < 1) return;

    const { x, y, w, h } = selectionRect;
    const zoom = 4;

    // –°—Ç–≤–æ—Ä—é—î–º–æ –º–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ
    const modal = document.createElement('div');
    modal.className = 'modal';
    document.body.appendChild(modal);

    const modalContent = document.createElement('div');
    modalContent.className = 'modal-content';
    modal.appendChild(modalContent);

    // ‚úÖ Canvas –∑–∞–≤–∂–¥–∏ –ø–æ–≤–Ω–æ–≥–æ —Ä–æ–∑–º—ñ—Ä—É (–±–µ–∑ –æ–±–º–µ–∂–µ–Ω—å)
    const editCanvas = document.createElement('canvas');
    editCanvas.className = 'modal-canvas';
    editCanvas.width = w * zoom;
    editCanvas.height = h * zoom;
    const editCtx = editCanvas.getContext('2d', { willReadFrequently: true });

    // –ó—á–∏—Ç—É—î–º–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏–π —Ñ—Ä–∞–≥–º–µ–Ω—Ç
    const srcData = history[historyIndex];
    const fragment = new ImageData(w, h);
    for (let sy = 0; sy < h; sy++) {
        for (let sx = 0; sx < w; sx++) {
            const srcIdx = ((y + sy) * srcData.width + (x + sx)) * 4;
            const dstIdx = (sy * w + sx) * 4;
            fragment.data[dstIdx]     = srcData.data[srcIdx];
            fragment.data[dstIdx + 1] = srcData.data[srcIdx + 1];
            fragment.data[dstIdx + 2] = srcData.data[srcIdx + 2];
            fragment.data[dstIdx + 3] = srcData.data[srcIdx + 3];
        }
    }

    // –ú–∞–ª—é—î–º–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç —É –∑–±—ñ–ª—å—à–µ–Ω–æ–º—É –≤–∏–≥–ª—è–¥—ñ
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = w;
    tempCanvas.height = h;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.putImageData(fragment, 0, 0);
    editCtx.imageSmoothingEnabled = false;
    editCtx.drawImage(tempCanvas, 0, 0, w, h, 0, 0, w * zoom, h * zoom);

    modalContent.appendChild(editCanvas);

    // Color picker —Ç–∞ –∫–Ω–æ–ø–∫–∏
    const colorPicker = document.createElement('input');
    colorPicker.type = 'color';
    colorPicker.value = '#000000';
    modalContent.appendChild(colorPicker);

    const buttonsDiv = document.createElement('div');
    buttonsDiv.className = 'modal-buttons';

    const applyBtn = document.createElement('button');
    applyBtn.textContent = '‚úÖ';
    applyBtn.style.color = 'green';
    applyBtn.style.fontWeight = 'bold';
    applyBtn.onclick = () => {
        // ‚úÖ –ß–∏—Ç–∞—î–º–æ –¥–∞–Ω—ñ –∑ –ø–æ–≤–Ω–æ–≥–æ canvas
        const scaledData = editCtx.getImageData(0, 0, w * zoom, h * zoom);
        const newFragment = new ImageData(w, h);

        for (let sy = 0; sy < h; sy++) {
            for (let sx = 0; sx < w; sx++) {
                const srcIdx = ((sy * zoom) * (w * zoom) + (sx * zoom)) * 4;
                const dstIdx = (sy * w + sx) * 4;
                newFragment.data[dstIdx]     = scaledData.data[srcIdx];
                newFragment.data[dstIdx + 1] = scaledData.data[srcIdx + 1];
                newFragment.data[dstIdx + 2] = scaledData.data[srcIdx + 2];
                newFragment.data[dstIdx + 3] = scaledData.data[srcIdx + 3];
            }
        }

        renderBaseOnly();
        ctx.putImageData(newFragment, x, y);
        saveState();
        document.body.removeChild(modal);
    };

    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = '‚ùå';
    cancelBtn.style.color = 'red';
    cancelBtn.onclick = () => {
        document.body.removeChild(modal);
    };

    buttonsDiv.appendChild(cancelBtn);
    buttonsDiv.appendChild(applyBtn);
    modalContent.appendChild(buttonsDiv);

    // –ü–µ–Ω–∑–µ–ª—å –¥–ª—è –º–∞–ª—é–≤–∞–Ω–Ω—è —É –º–æ–¥–∞–ª—å–Ω–æ–º—É –≤—ñ–∫–Ω—ñ
    let isDrawingEdit = false;
    let lastX, lastY;

    editCanvas.onmousedown = (e) => {
        isDrawingEdit = true;
        const rect = editCanvas.getBoundingClientRect();
        lastX = Math.floor((e.clientX - rect.left));
        lastY = Math.floor((e.clientY - rect.top));
        drawPixel(lastX, lastY);
    };

    editCanvas.onmousemove = (e) => {
        if (!isDrawingEdit) return;
        const rect = editCanvas.getBoundingClientRect();
        const currX = Math.floor((e.clientX - rect.left));
        const currY = Math.floor((e.clientY - rect.top));
        drawLine(lastX, lastY, currX, currY, colorPicker.value, editCtx, zoom);
        lastX = currX;
        lastY = currY;
    };

    editCanvas.onmouseup = () => isDrawingEdit = false;
    editCanvas.onmouseleave = () => isDrawingEdit = false;

    function drawPixel(px, py) {
        const size = zoom;
        const x = Math.floor(px / zoom) * zoom;
        const y = Math.floor(py / zoom) * zoom;
        editCtx.fillStyle = colorPicker.value;
        editCtx.fillRect(x, y, zoom, zoom);
    }

    function drawLine(x0, y0, x1, y1, color, context, blockSize) {
        const steps = Math.max(Math.abs(x1 - x0), Math.abs(y1 - y0)) / blockSize;
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const x = Math.round(x0 + t * (x1 - x0));
            const y = Math.round(y0 + t * (y1 - y0));
            const gridX = Math.floor(x / blockSize) * blockSize;
            const gridY = Math.floor(y / blockSize) * blockSize;
            context.fillStyle = color;
            context.fillRect(gridX, gridY, blockSize, blockSize);
        }
    }
}
// –§—É–Ω–∫—Ü—ñ—ó
function openImage() {
    document.getElementById('fileInput').click();
}

document.getElementById('fileInput').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
            if (img.width > canvas.width || img.height > canvas.height) {
                alert(`–ó–æ–±—Ä–∞–∂–µ–Ω–Ω—è –∑–∞–≤–µ–ª–∏–∫–µ!\n–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∏–π —Ä–æ–∑–º—ñ—Ä: ${canvas.width}√ó${canvas.height}\n–í–∞—à–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è: ${img.width}√ó${img.height}`);
                return;
            }
            
            //ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0);
            saveState();
            selectionRect = null;
            floatingLayer = null;
            render();
        };
        img.src = event.target.result;
    };
    reader.readAsDataURL(file);
});

function saveImage() {
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = canvas.width;
    exportCanvas.height = canvas.height;
    const exportCtx = exportCanvas.getContext('2d');
    
    if (historyIndex >= 0) {
        exportCtx.putImageData(history[historyIndex], 0, 0);
    } else {
        exportCtx.drawImage(canvas, 0, 0);
    }
    
    const link = document.createElement('a');
    link.download = 'canvas-image.png';
    link.href = exportCanvas.toDataURL('image/png');
    link.click();
}
//
function mirrorFloatingLayer(vertical = false, horizontal = false) {
  if (!floatingLayer) return;

  const { original } = floatingLayer;
  const w = original.width;
  const h = original.height;
  const mirrored = new ImageData(w, h);

  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const srcX = horizontal ? w - 1 - x : x;
      const srcY = vertical ? h - 1 - y : y;
      const srcIdx = (srcY * w + srcX) * 4;
      const dstIdx = (y * w + x) * 4;

      mirrored.data[dstIdx]     = original.data[srcIdx];
      mirrored.data[dstIdx + 1] = original.data[srcIdx + 1];
      mirrored.data[dstIdx + 2] = original.data[srcIdx + 2];
      mirrored.data[dstIdx + 3] = original.data[srcIdx + 3];
    }
  }

  floatingLayer.original = mirrored;
  render();
}

// –û–±—Ä–æ–±–Ω–∏–∫–∏
document.getElementById('openBtn').onclick = openImage;
document.getElementById('saveBtn').onclick = saveImage;
// –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –≤–∏–¥–∏–º–æ—Å—Ç—ñ –∫–æ–Ω—Ç—Ä–æ–ª—ñ–≤
document.querySelector('.brush-controls').style.display = 'flex';
document.querySelector('.eraser-controls').style.display = 'none';
// –§–æ–∫—É—Å—É—î–º–æ canvas –¥–ª—è –æ—Ç—Ä–∏–º–∞–Ω–Ω—è –ø–æ–¥—ñ–π –∫–ª–∞–≤—ñ–∞—Ç—É—Ä–∏
canvas.tabIndex = 0;
canvas.focus();

// –ü—Ä–∏ –∫–ª—ñ–∫—É –Ω–∞ canvas ‚Äî —Ñ–æ–∫—É—Å—É—î–º–æ
canvas.addEventListener('click', () => {
    canvas.focus();
});
</script>
</body>
</html>
