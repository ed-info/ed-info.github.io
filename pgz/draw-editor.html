<!DOCTYPE html>
<html lang="uk">
	<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Canvas Draw</title>
<style>
body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}	
/* –í–µ—Ä—Ö–Ω—è –ø–∞–Ω–µ–ª—å */
.cd-top-toolbar {
  background: #111;
  color: white;
  padding: 6px 8px;
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
  flex-shrink: 0;
}
/* –û—Å–Ω–æ–≤–Ω–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç */
.main-content {
  display: flex;
  flex: 1;
  overflow: hidden;
}
/* –ú–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}
.modal-content {
  background: white;
  padding: 16px;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  max-width: 90vw;
  max-height: 70vh;
  overflow: auto;
  z-index: 10000;
  width: 300px;
}
.modal-canvas {
  border: 1px solid #999;
  background: white;
  max-width: 100%;
  max-height: 60vh;
  display: block;
}
.modal-buttons {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
}
/* –ë—ñ—á–Ω–∞ –ø–∞–Ω–µ–ª—å */
.side-toolbar {
  background: #111;
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 8px;
  min-width: 70px;
  flex-shrink: 0;
}
/* –ö–Ω–æ–ø–∫–∏ */
.top-icon-btn,
.cd-toolbar-button {
  background: none;
  border: none;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 4px;
  border-radius: 4px;
  color: white;
}
.top-icon-btn {
  width: 44px;
  height: 44px;
}
.top-icon-btn:hover {
  background: #555;
}
.top-icon-btn img,
.cd-toolbar-button img {
  display: block;
  image-rendering: -webkit-crisp-edges;
  image-rendering: crisp-edges;
}
.top-icon-btn img {
  width: 32px;
  height: 32px;
}
.cd-toolbar-button {
  width: 40px;
  height: 40px;
}
.cd-toolbar-button img {
  width: 32px;
  height: 32px;
}
.cd-toolbar-button.active {
  background: #ffcc00;
  border-radius: 4px;
}

/* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä canvas ‚Äî —à–∞—Ö–æ–≤–∞ –ø—ñ–¥–∫–ª–∞–¥–∫–∞ */
.canvas-container {
  position: relative;
  display: inline-block;
  background-image:
    linear-gradient(45deg, #ccc 25%, transparent 25%),
    linear-gradient(-45deg, #ccc 25%, transparent 25%),
    linear-gradient(45deg, transparent 75%, #ccc 75%),
    linear-gradient(-45deg, transparent 75%, #ccc 75%);
  background-size: 20px 20px;
  background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
}
.canvas-center-wrapper {
  display: flex;
  justify-content: center;
  align-items: center;
  flex: 1;
  overflow: auto;
  background-color: #aaa;
}
#cd-canvas {
  display: block;
  background: transparent;
  border: 1px solid #999;
  image-rendering: pixelated;
}

#canvasResizeHandle {
  position: absolute;
  right: 0;
  bottom: 0;
  width: 12px;
  height: 12px;
  background: #00aaff;
  border: 1px solid #000;
  cursor: nwse-resize;
  z-index: 20;
  transform-origin: bottom right;
}


#zoomWrapper {
  position: relative;
  display: inline-block;
  transform-origin: top left;
}

.selection-only {
  display: none;
}
/* –ö—É—Ä—Å–æ—Ä –≥—É–º–∫–∏ */
#eraserCursor {
  position: absolute;
  pointer-events: none;
  border: 2px solid #000;
  border-radius: 50%;
  display: none;
  transform: translate(-50%, -50%);
}
/* –ù–∏–∂–Ω—è –ø–∞–Ω–µ–ª—å */
.cd-bottom-toolbar {
  background: #111;
  padding: 4px 8px;
  display: flex;
  align-items: center;
  gap: 6px;
  flex-shrink: 0;
  height: 40px;
  margin-bottom:15px;
}

.color-palette {
  display: flex;
  flex-wrap: wrap;
  gap: 2px;
  width: 352px; /* 16 –∫–Ω–æ–ø–æ–∫ √ó (20px + 2px gap) - 2px –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ gap */
  max-height: 32px; /* 2 —Ä—è–¥–∏ √ó (14px + 2px gap) */
}

.color-palette button {
  width: 20px;
  height: 14px; /* –∑–º–µ–Ω—à–µ–Ω–∞ –≤–∏—Å–æ—Ç–∞ */
  border: 1px solid #666;
  border-radius: 2px;
  cursor: pointer;
  padding: 0;
  margin: 0;
  flex-shrink: 0;
}
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none; /* –ü—Ä–∏—Ö–æ–≤–∞–Ω–æ –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º */
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(2px);
        }
        .modal-input-wrapper {
            margin: 20px 0;
        }

        .modal-input-wrapper input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
            box-sizing: border-box;
        }

        .modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        .btn {
            padding: 8px 20px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: 600;
        }

        .btn-ok { background: #28a745; color: white; }
        .btn-cancel { background: #dc3545; color: white; }
        .btn-ok:hover { background: #218838; }
        .btn-cancel:hover { background: #c82333; }

		</style>
	</head>
	<body>
		<div id="cdraw-editor" style="margin: 0; background: #eee; font-family: sans-serif; display: flex; flex-direction: column; height: 100vh; overflow: hidden;">
			<div class="cd-top-toolbar">
				<img src="images/cdlogo.png" alt="CDraw" style="margin-top:5px;">
				<button id="openBtn" class="top-icon-btn">
					<img src="images/open.png" alt="Open">
				</button>
				<button id="saveBtn" class="top-icon-btn">
					<img src="images/save.png" alt="Save">
				</button>
				<button id="undoBtn" class="top-icon-btn">
					<img src="images/undo.png" alt="Undo">
				</button>
				<button id="redoBtn" class="top-icon-btn">
					<img src="images/redo.png" alt="Redo">
				</button>
				<button id="zoomOutBtn" class="top-icon-btn">
					<img src="images/zoom-out.png" alt="Zoom Out">
				</button>
				<button id="zoom11Btn" class="top-icon-btn">
					<img src="images/zoom-11.png" alt="1:1">
				</button>
				<button id="zoomInBtn" class="top-icon-btn">
					<img src="images/zoom-in.png" alt="Zoom In">
				</button>				
				<input type="file" id="fileInput" accept="image/*" style="display:none;">

				<button id="rotateCWBtn" class="top-icon-btn">
					<img src="images/rotate-cw.png" alt="Rotate clockwise">
				</button>
				<button id="shrinkBtn" class="top-icon-btn">
					<img src="images/shrink.png" alt="Shrink image">
				</button>
				<button id="rotateBtn" class="top-icon-btn selection-only">
					<img src="images/rotate.png" alt="Rotate">
				</button>
				<button id="copyBtn" class="top-icon-btn selection-only">
					<img src="images/copy.png" alt="Copy">
				</button>
				<button id="pasteBtn" class="top-icon-btn">
					<img src="images/paste.png" alt="Paste">
				</button>
				<button id="deleteBtn" class="top-icon-btn selection-only">
					<img src="images/delete.png" alt="Delete">
				</button>
				<button id="vmirrorBtn" class="top-icon-btn selection-only">
					<img src="images/vmirror.png" alt="Vertical Mirror">
				</button>
				<button id="hmirrorBtn" class="top-icon-btn selection-only">
					<img src="images/hmirror.png" alt="Horizontal Mirror">
				</button>
				<div class="eraser-controls" style="display: flex; align-items: center; gap: 6px; white-space: nowrap;">
					<img src="images/eraser_w.png" alt="Eraser size" width="32" height="32">
					<input type="range" id="eraserSize" min="2" max="50" value="20" style="width:80px;">
					<span id="eraserSizeLabel">20</span>
				</div>
                <div class="brush-controls" style="display: flex; align-items: center; gap: 6px; white-space: nowrap;">
                	<img src="images/brush_w.png" alt="Brush size" width="32" height="32">
                	<input type="range" id="brushSize" min="1" max="50" value="2" style="width:80px;">                		
                	<span id="brushSizeLabel" style="width: 2.2ch; text-align: right;">2</span>                	
                </div>


				<button id="closeBtn" class="top-icon-btn" style="margin-left: auto;">
					<img src="images/exit.png" alt="Exit">
				</button>
			</div>
			<div class="main-content">
				<div class="side-toolbar">
					<button id="brushBtn" class="cd-toolbar-button active">
						<img src="images/brush.png" alt="–ü–µ–Ω–∑–µ–ª—å">
					</button>
					<button id="eraserBtn" class="cd-toolbar-button">
						<img src="images/eraser.png" alt="–ì—É–º–∫–∞">
					</button>
					<button id="lineBtn" class="cd-toolbar-button">
						<img src="images/line.png" alt="–õ—ñ–Ω—ñ—è">
					</button>
					<button id="rectBtn" class="cd-toolbar-button">
						<img src="images/rect.png" alt="–ü—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫">
					</button>
					<button id="rectStrokeBtn" class="cd-toolbar-button">
						<img src="images/rect-stroke.png" alt="–ù–µ–∑–∞–ø–æ–≤–Ω–µ–Ω–∏–π –ø—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫">
					</button>
					<button id="ellipseBtn" class="cd-toolbar-button">
						<img src="images/ellipse.png" alt="–ï–ª—ñ–ø—Å">
					</button>
					<button id="ellipseStrokeBtn" class="cd-toolbar-button">
						<img src="images/ellipse-stroke.png" alt="–ù–µ–∑–∞–ø–æ–≤–Ω–µ–Ω–∏–π –µ–ª—ñ–ø—Å">
					</button>
					<button id="selectBtn" class="cd-toolbar-button">
						<img src="images/select.png" alt="–í–∏–¥—ñ–ª–µ–Ω–Ω—è">
					</button>
					<button id="fillBtn" class="cd-toolbar-button">
						<img src="images/fill.png" alt="–ó–∞–ø–æ–≤–Ω–µ–Ω–Ω—è">
					</button>
					<button id="textBtn" class="cd-toolbar-button">
						<img src="images/text.png" alt="–¢–µ–∫—Å—Ç">
					</button>
					<button id="eyedropperBtn" class="cd-toolbar-button">
						<img src="images/eyedropper.png" alt="–ü—ñ–ø–µ—Ç–∫–∞">
					</button>
					<button id="clearBtn" class="cd-toolbar-button">
						<img src="images/clear.png" alt="Clear">
					</button>
				</div>
				<div class="canvas-center-wrapper">
					<div id="zoomWrapper">
						
						<!-- –¶–µ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –º–∞—î —à–∞—Ö–æ–≤—É –ø—ñ–¥–∫–ª–∞–¥–∫—É -->
						<div class="canvas-container" id="canvasContainer">
							<canvas id="cd-canvas" width="128" height="128"></canvas>
							
							<!-- üîë resize handle –ü–†–ò–í º–Ø–ó–ê–ù–ò–ô –¥–æ canvas -->
							<div id="canvasResizeHandle"></div>
						</div>
					</div>
				</div>
			</div>
			<div class="cd-bottom-toolbar">
				<input type="color" id="colorPicker" value="#000000">
				<div class="color-palette" id="colorPalette"></div>
				<img src="images/zoom-range.png" alt="–ú–∞—Å—à—Ç–∞–±">
				<span id="zoomIndicator" style="color:white; font-size:14px;">100%</span>
			</div>
			<div id="eraserCursor"></div>
		</div>
		<div id="modal-container" class="modal-overlay" style="display:none;">
			<div class="modal-content">
				<h3 id="modal-title">–ó–∞–≥–æ–ª–æ–≤–æ–∫</h3>
				<p id="modal-text">–¢–µ–∫—Å—Ç –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è...</p>
				<div id="modal-input-wrapper" class="modal-input-wrapper" style="display: none;">
					<input type="text" id="modal-input-field" placeholder="–í–≤–µ–¥—ñ—Ç—å —Ç–µ–∫—Å—Ç —Ç—É—Ç...">
				</div>
				<div class="modal-buttons">
					<button id="modal-cancel-btn" class="btn btn-cancel">–ù—ñ</button>					
					<button id="modal-ok-btn" class="btn btn-ok">–¢–∞–∫</button>
				</div>
			</div>
		</div>
		<script src="./lib/jsfs2.js"></script>
		<script>
document.addEventListener('DOMContentLoaded', () => {
    // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è —Ñ–∞–π–ª–æ–≤–æ—ó —Å–∏—Å—Ç–µ–º–∏
    if (typeof window.FileSystem === 'undefined') {
        message('–ü–æ–º–∏–ª–∫–∞: –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ jsfs –Ω–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–∞!');
    } else {
        window.jsfs = new window.FileSystem("PGZfs");
    }
// CDraw libs ====================
const canvas = document.getElementById('cd-canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const eraserCursor = document.getElementById('eraserCursor');
const resizeHandle = document.getElementById('canvasResizeHandle');

/* -------- STATE -------- */
let tool = 'brush';
let isDrawing = false;
let isSelecting = false;
let isDraggingFloating = false;
let dragOffsetX = 0, dragOffsetY = 0;
let startX = 0, startY = 0;
let selectionRect = null;
let floatingLayer = null;
let clipboardData = null;
let history = [];
let historyIndex = -1;
let dashOffset = 0;
let currentShape = null;
let currentBrushPath = [];
let isResizing = false;
let resizeHandleType = null;
let originalClipboard = null;
let transformMode = 'scale';
let isRotating = false;
let startAngle = 0;
let brushSize = 2;
let eraserSize = 20;
let lineStart = null;
let mousePos = { x: 0, y: 0 };
let textContent = '';
let textPosition = null;
let isEditingText = false;
let cursorVisible = true;
let cursorBlinkInterval = null;
let isResizingCanvas = false;
let startWidth = 0, startHeight = 0;
let startClientX = 0, startClientY = 0;
let wasDragged = false;
let brushClickStart = null;
let currentZoom = 1;
const minZoom = 0.1;
const maxZoom = 8;
const zoomStep = 0.1;
let openedFromFS = false;
let openedFSPath = null;
let loadPath = null;
/* -------- INIT -------- */
const initialData = ctx.createImageData(canvas.width, canvas.height);
ctx.putImageData(initialData, 0, 0);
saveState();
animateAnts();
updatePasteButtonVisibility();
const canvasContainer = document.getElementById('canvasContainer');
canvasContainer.style.width = canvas.width + 'px';
canvasContainer.style.height = canvas.height + 'px';
const handle = document.getElementById('canvasResizeHandle');
handle.style.transform = `translate(${8}px, ${8}px) scale(${1})`;;  
// –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è 32 –∫–æ–ª—å–æ—Ä—ñ–≤ (–º–æ–∂–Ω–∞ –Ω–∞–ª–∞—à—Ç—É–≤–∞—Ç–∏)
const defaultColors = [
  // –ß–æ—Ä–Ω–æ-–±—ñ–ª–∞ –≥–∞–º–º–∞
  '#000000', '#ffffff',
  // –û—Å–Ω–æ–≤–Ω—ñ –∫–æ–ª—å–æ—Ä–∏
  '#ff0000', '#00ff00', '#0000ff',
  '#ffff00', '#ff00ff', '#00ffff',
  // –í—ñ–¥—Ç—ñ–Ω–∫–∏ —Å—ñ—Ä–æ–≥–æ
  '#808080', '#c0c0c0', '#a9a9a9', '#696969',
  // –î–æ–¥–∞—Ç–∫–æ–≤—ñ –∫–æ–ª—å–æ—Ä–∏
  '#ffa500', '#800080', '#008000', '#000080',
  '#808000', '#ffc0cb', '#dda0dd', '#90ee90',
  '#add8e6', '#f0e68c', '#d2b48c', '#ffb6c1',
  '#2f4f4f', '#556b2f', '#8b4513', '#483d8b',
  '#2e8b57', '#b22222', '#ff4500', '#daa520'
];

// –û–±—Ä—ñ–∑–∞—î–º–æ –¥–æ 32, —è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ
const paletteColors = defaultColors.slice(0, 32);

const colorPalette = document.getElementById('colorPalette');
paletteColors.forEach(color => {
  const btn = document.createElement('button');
  btn.style.backgroundColor = color;
  btn.title = color;
  btn.onclick = () => {
    document.getElementById('colorPicker').value = color;
  };
  colorPalette.appendChild(btn);
});

// –°–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—è –º—ñ–∂ –∫–æ–ª–æ—Ä-–ø—ñ–∫–µ—Ä–∞–º–∏
document.getElementById('colorPicker').oninput = (e) => {
  document.getElementById('colorPicker').value = e.target.value;
};
//

// draw-editor.html ‚Äî –ø—Ä–∏ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—ñ
async function preload() {
const params = new URLSearchParams(window.location.search);
loadPath = params.get('load');

    if (loadPath) {
        try {
            // –ü—Ä–∏–ø—É—Å–∫–∞—î–º–æ, —â–æ jsfs –¥–æ—Å—Ç—É–ø–Ω–∏–π —É –≥–ª–æ–±–∞–ª—å–Ω–æ–º—É –∫–æ–Ω—Ç–µ–∫—Å—Ç—ñ
            if (typeof window.jsfs === 'undefined') {
                await message('','–§–∞–π–ª–æ–≤–∞ —Å–∏—Å—Ç–µ–º–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞');
                return;
            }

            const base64Data = await window.jsfs.read(loadPath);            
            if (typeof base64Data !== 'string') {
                await message('','–ù–µ–≤—ñ—Ä–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª—É');
                return;
            }

            const img = new Image();
            img.onload = () => {
                canvas.width = img.width;
                canvas.height = img.height;
                const container = document.getElementById('canvasContainer');
                if (container) {
                    container.style.width = img.width + 'px';
                    container.style.height = img.height + 'px';
                }
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                // –û–Ω–æ–≤–∏—Ç–∏ —Å—Ç–∞–Ω, —è–∫ —É –≤–∞—à–æ–º—É –æ–±—Ä–æ–±–Ω–∏–∫—É
                saveState();
                selectionRect = null;
                floatingLayer = null;
                applyZoom(currentZoom);
                openedFromFS = true;
                openedFSPath = loadPath;
                render();
            };
            img.onerror = () =>  message('','–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞–≤–∞–Ω—Ç–∞–∂–∏—Ç–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è');
            img.src = base64Data;
        } catch (err) {
            console.error('–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è:', err);
            await message('','–ü–æ–º–∏–ª–∫–∞: ' + (err.message || ''));
        }
    }
}
preload();
/* -------- TOOLS -------- */
// –ü—ñ—Å–ª—è –∑–∞–≥–∞–ª—å–Ω–æ–≥–æ —Ü–∏–∫–ª—É:
['brush','rect','ellipse','rectStroke','ellipseStroke','select','fill','eraser','line','text','eyedropper'].forEach(t=>{
  if (document.getElementById(t+'Btn')) {
    document.getElementById(t+'Btn').onclick=()=>setTool(t);
  }
});

// üîÅ –ü–µ—Ä–µ–≤–∏–∑–Ω–∞—á–∞—î–º–æ selectBtn –æ–∫—Ä–µ–º–æ:
document.getElementById('selectBtn').onclick = () => {
  if (tool === 'select') {
    // –í–∏–¥—ñ–ª–∏—Ç–∏ –≤—Å–µ –ø–æ–ª–æ—Ç–Ω–æ
    selectionRect = { x: 0, y: 0, w: canvas.width, h: canvas.height };
    updateSelectionButtons();
    render();
  } else {
    setTool('select');
  }
};
document.getElementById('rotateCWBtn').onclick = () => {
	rotateCW();
}
document.getElementById('shrinkBtn').onclick = () => {
	shrinkIMG();
}
document.getElementById('rotateBtn').onclick = () => {
  // –Ø–∫—â–æ —î –≤–∏–¥—ñ–ª–µ–Ω–Ω—è, –∞–ª–µ –Ω–µ–º–∞—î floating layer ‚Äî —Å—Ç–≤–æ—Ä—é—î–º–æ –π–æ–≥–æ
  if (selectionRect && !floatingLayer) {
    createFloatingFromSelection();
    if (!floatingLayer) return; // —è–∫—â–æ –Ω–µ –≤–¥–∞–ª–æ—Å—è
  }

  if (!floatingLayer) return;

  const rotateBtnImg = document.getElementById('rotateBtn').querySelector('img');
  if (transformMode === 'scale') {
    transformMode = 'rotate';
    rotateBtnImg.src = 'images/scale.png';
    rotateBtnImg.alt = 'Scale';
  } else {
    transformMode = 'scale';
    rotateBtnImg.src = 'images/rotate.png';
    rotateBtnImg.alt = 'Rotate';
  }
  render();
};

document.getElementById('clearBtn').onclick = clearCanvas;

document.getElementById('eraserSize').oninput = (e) => {
  eraserSize = parseInt(e.target.value);
  document.getElementById('eraserSizeLabel').textContent = eraserSize;
};
document.getElementById('brushSize').oninput = (e) => {
  brushSize = parseInt(e.target.value);
  document.getElementById('brushSizeLabel').textContent = brushSize;
};

document.getElementById('vmirrorBtn').onclick = () => {
  if (selectionRect && !floatingLayer) {
    createFloatingFromSelection();
    if (!floatingLayer) return;
  }
  if (floatingLayer) mirrorFloatingLayer(true, false);
};

document.getElementById('hmirrorBtn').onclick = () => {
  if (selectionRect && !floatingLayer) {
    createFloatingFromSelection();
    if (!floatingLayer) return;
  }
  if (floatingLayer) mirrorFloatingLayer(false, true);
};

document.getElementById('closeBtn').onclick = async () => {
  let shouldExit = false;

  if (loadPath) {
    // –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –±–µ–∑ –∑–∞–ø–∏—Ç—É, –±–æ —Ñ–∞–π–ª –≤–∂–µ –º–∞—î —à–ª—è—Ö
    await saveToFS(loadPath);
    console.log('*–§–∞–π–ª –∑–±–µ—Ä–µ–∂–µ–Ω–æ:', loadPath);
    const ask = await askConfirm("", "–ó–∞–∫—ñ–Ω—á–∏—Ç–∏ —Ä–æ–±–æ—Ç—É?");
    if (ask) {
      shouldExit = true;
    }
  } else {
    // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —î –Ω–µ–∑–±–µ—Ä–µ–∂–µ–Ω—ñ –∑–º—ñ–Ω–∏
    const hasUnsavedChanges = !openedFromFS || historyIndex > 0;

    if (hasUnsavedChanges) {
      const shouldSave = await askConfirm('–ù–µ–∑–±–µ—Ä–µ–∂–µ–Ω—ñ –∑–º—ñ–Ω–∏', '–•–æ—á–µ—Ç–µ –∑–±–µ—Ä–µ–≥—Ç–∏ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –ø–µ—Ä–µ–¥ –≤–∏—Ö–æ–¥–æ–º?');
      if (shouldSave) {
        const fileName = await input('–ó–±–µ—Ä–µ–≥—Ç–∏', '–í–≤–µ–¥—ñ—Ç—å —ñ–º‚Äô—è —Ñ–∞–π–ª—É –±–µ–∑ —Ä–æ–∑—à–∏—Ä–µ–Ω–Ω—è (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥: my_art):');
        if (fileName && fileName.trim() !== '') {
          const cleanName = fileName.trim();
          const fullPath = `images/${cleanName}.png`;
          await saveToFS(fullPath);
          console.log('–§–∞–π–ª –∑–±–µ—Ä–µ–∂–µ–Ω–æ:', fullPath);
        }
        // –ù–∞–≤—ñ—Ç—å —è–∫—â–æ —ñ–º‚Äô—è –Ω–µ –≤–≤–µ–¥–µ–Ω–æ ‚Äî –ø—Ä–æ–¥–æ–≤–∂—É—î–º–æ –≤–∏—Ö—ñ–¥
      }
      // –ü—ñ—Å–ª—è –∑–∞–ø–∏—Ç—É –ø—Ä–æ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è ‚Äî –∑–∞–ø–∏—Ç—É—î–º–æ, —á–∏ —Ç–æ—á–Ω–æ –≤–∏—Ö–æ–¥–∏—Ç–∏
      const confirmExit = await askConfirm("", "–ó–∞–∫—ñ–Ω—á–∏—Ç–∏ —Ä–æ–±–æ—Ç—É?");
      if (confirmExit) {
        shouldExit = true;
      }
    } else {
      // –ù–µ–º–∞—î –∑–º—ñ–Ω ‚Äî –≤–∏—Ö–æ–¥–∏–º–æ –±–µ–∑ –ø–æ–ø–µ—Ä–µ–¥–∂–µ–Ω—å
      shouldExit = true;
    }
  }

  if (shouldExit) {
    window.parent.postMessage('closeEditor', '*');
  }
};
canvas.ondragstart = () => false;

function updatePasteButtonVisibility() {
	const pasteBtn = document.getElementById('pasteBtn');
	if (selectionRect && clipboardData) {
		pasteBtn.style.display = 'inline-block'; // –∞–±–æ 'flex'
	} else {
		pasteBtn.style.display = 'none';
	}
}

function setTool(t){
	console.log("tool=",t)
  tool = t;
  document.querySelectorAll('.cd-toolbar-button').forEach(b => b.classList.remove('active'));
  document.getElementById(t+'Btn').classList.add('active');
  canvas.style.cursor = (t === 'eyedropper') ? 'crosshair' : 'default';
  selectionRect = null;
  floatingLayer = null;
  brushClickStart = null;
  lineStart = null;
  if (isEditingText) finishTextEditing();
  render();
  updateSelectionButtons();
  const brushControls = document.querySelector('.brush-controls');
  const eraserControls = document.querySelector('.eraser-controls');
  if (brushControls && eraserControls) {
    brushControls.style.display = (tool === 'brush') ? 'flex' : 'none';
    eraserControls.style.display = (tool === 'eraser') ? 'flex' : 'none';
  }
}

async function clearCanvas() {
  const shouldClear = await askConfirm('–ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è', '–û—á–∏—Å—Ç–∏—Ç–∏ –≤—Å–µ –ø–æ–ª–æ—Ç–Ω–æ?');
  if (shouldClear) {
    const clearData = ctx.createImageData(canvas.width, canvas.height);
    ctx.putImageData(clearData, 0, 0);
    selectionRect = null;
    floatingLayer = null;
    saveState();
    render();
    updateSelectionButtons();
  }
}

function applyZoom(zoomLevel) {
    currentZoom = Math.max(minZoom, Math.min(maxZoom, zoomLevel));
    const zoomWrapper = document.getElementById('zoomWrapper');
    zoomWrapper.style.transform = `scale(${currentZoom})`;
    zoomWrapper.style.transformOrigin = 'top left';

    // –û–Ω–æ–≤–ª—é—î–º–æ —Ä–æ–∑–º—ñ—Ä .canvas-container –ø—ñ–¥ –ø–æ—Ç–æ—á–Ω–∏–π —Ä–æ–∑–º—ñ—Ä canvas
    const canvas = document.getElementById('cd-canvas');
    const container = document.getElementById('canvasContainer');
    container.style.width = canvas.width + 'px';
    container.style.height = canvas.height + 'px';
	const offset = 8;
	const handle = document.getElementById('canvasResizeHandle');
	handle.style.transform = `translate(${offset}px, ${offset}px) scale(${1 / currentZoom})`;;

    // –û–Ω–æ–≤–ª–µ–Ω–Ω—è —ñ–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞
    const indicator = document.getElementById('zoomIndicator');
    if (indicator) {
        indicator.textContent = Math.round(currentZoom * 100) + '%';
    }
}

document.getElementById('zoomInBtn').onclick = () => {
    applyZoom(currentZoom + zoomStep);
};

document.getElementById('zoomOutBtn').onclick = () => {
    applyZoom(currentZoom - zoomStep);
};

document.getElementById('zoom11Btn').onclick = () => {
    applyZoom(1);
};


function updateSelectionButtons() {
  const hasSelection = selectionRect !== null || floatingLayer !== null;
  const buttons = document.querySelectorAll('.selection-only');
  buttons.forEach(btn => {
    btn.style.display = hasSelection ? 'flex' : 'none';
  });
}

/* -------- HISTORY -------- */
function saveState(){
  history = history.slice(0, historyIndex + 1);
  history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
  historyIndex++;
}
function undo() {
  if (historyIndex > 0) {
    historyIndex--;
    const prevState = history[historyIndex];
    
    // üîë –°–∫–∏–¥–∞—î–º–æ —Ä–æ–∑–º—ñ—Ä canvas –¥–æ —Ä–æ–∑–º—ñ—Ä—É –∑–±–µ—Ä–µ–∂–µ–Ω–æ–≥–æ —Å—Ç–∞–Ω—É
    canvas.width = prevState.width;
    canvas.height = prevState.height;
    
    // üîë –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.imageSmoothingEnabled = false;
    
    // –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
    ctx.putImageData(prevState, 0, 0);
    
    // –û–Ω–æ–≤–ª—é—î–º–æ —Ä–æ–∑–º—ñ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
    const canvasContainer = document.querySelector('.canvas-container');
    canvasContainer.style.width = canvas.width + 'px';
    canvasContainer.style.height = canvas.height + 'px';
    
    selectionRect = null;
    floatingLayer = null;
    render();
    updateSelectionButtons();
  }
}

function redo() {
  if (historyIndex < history.length - 1) {
    historyIndex++;
    const nextState = history[historyIndex];
    
    // üîë –°–∫–∏–¥–∞—î–º–æ —Ä–æ–∑–º—ñ—Ä canvas
    canvas.width = nextState.width;
    canvas.height = nextState.height;
    
    // üîë –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.imageSmoothingEnabled = false;
    
    ctx.putImageData(nextState, 0, 0);
    
    // –û–Ω–æ–≤–ª—é—î–º–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
    const canvasContainer = document.querySelector('.canvas-container');
    canvasContainer.style.width = canvas.width + 'px';
    canvasContainer.style.height = canvas.height + 'px';
    
    selectionRect = null;
    floatingLayer = null;
    render();
    updateSelectionButtons();
  }
}
// –ü—ñ—Å–ª—è –æ–≥–æ–ª–æ—à–µ–Ω–Ω—è —Ñ—É–Ω–∫—Ü—ñ–π undo/redo
document.getElementById('undoBtn').onclick = undo;
document.getElementById('redoBtn').onclick = redo;
//
// –û–±—Ä–æ–±–Ω–∏–∫–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è
document.getElementById('copyBtn').addEventListener('click', copySelection);
document.getElementById('pasteBtn').addEventListener('click', pasteSelection);
document.getElementById('deleteBtn').addEventListener('click', deleteSelection);
/* --------------- FLOOD FILL --------------- */
function floodFill(ctx, x, y, fillColorHex, tolerance = 32) {
  const canvas = ctx.canvas;
  const width = canvas.width;
  const height = canvas.height;
  const imageData = ctx.getImageData(0, 0, width, height);
  const data = imageData.data;

  const hexToRgb = (hex) => {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return { r, g, b };
  };

  const getColor = (x, y) => {
    const i = (y * width + x) * 4;
    return { r: data[i], g: data[i+1], b: data[i+2], a: data[i+3] };
  };

  const setColor = (x, y, color) => {
    const i = (y * width + x) * 4;
    data[i] = color.r;
    data[i+1] = color.g;
    data[i+2] = color.b;
    data[i+3] = 255;
  };

  const targetColor = getColor(x, y);
  const replacementColor = hexToRgb(fillColorHex);

  // –Ø–∫—â–æ –≤–∂–µ –∑–∞—Ñ–∞—Ä–±–æ–≤–∞–Ω–æ —Ü–∏–º –∫–æ–ª—å–æ—Ä–æ–º ‚Äî –Ω—ñ—á–æ–≥–æ –Ω–µ —Ä–æ–±–∏—Ç–∏
  if (targetColor.r === replacementColor.r &&
      targetColor.g === replacementColor.g &&
      targetColor.b === replacementColor.b &&
      targetColor.a === 255) {
    return;
  }

  const colorDistance = (c1, c2) => {
    const dr = c1.r - c2.r;
    const dg = c1.g - c2.g;
    const db = c1.b - c2.b;
    return Math.sqrt(dr*dr + dg*dg + db*db);
  };

  const visited = new Uint8Array(width * height);
  const stack = [{ x, y }];
  visited[y * width + x] = 1;

  while (stack.length > 0) {
    const { x, y } = stack.pop();
    setColor(x, y, replacementColor);
    const neighbors = [[x+1,y],[x-1,y],[x,y+1],[x,y-1]];
    for (const [nx, ny] of neighbors) {
      if (nx < 0 || ny < 0 || nx >= width || ny >= height) continue;
      const idx = ny * width + nx;
      if (visited[idx]) continue;
      const neighborColor = getColor(nx, ny);

      // üîë –°–ü–ï–¶–Ü–ê–õ–¨–ù–ê –û–ë–†–û–ë–ö–ê –ü–†–û–ó–û–†–û–°–¢–Ü
      if (targetColor.a === 0) {
        // –ó–∞–ª–∏–≤–∞—î–º–æ –ª–∏—à–µ –ø—Ä–æ–∑–æ—Ä—ñ –ø—ñ–∫—Å–µ–ª—ñ
        if (neighborColor.a !== 0) continue;
      } else {
        // –ó–∞–ª–∏–≤–∞—î–º–æ –ª–∏—à–µ –Ω–µ–ø—Ä–æ–∑–æ—Ä—ñ –ø—ñ–∫—Å–µ–ª—ñ –∑ –ø–æ–¥—ñ–±–Ω–∏–º –∫–æ–ª—å–æ—Ä–æ–º
        if (neighborColor.a === 0) continue;
        if (colorDistance(neighborColor, targetColor) > tolerance) continue;
      }

      visited[idx] = 1;
      stack.push({ x: nx, y: ny });
    }
  }
  ctx.putImageData(imageData, 0, 0);
}

function rgbToHex(r, g, b) {
  return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
}

/* -------- COORDINATE HELPER -------- */
function getCanvasCoords(e) {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  return {
    x: Math.floor(x * scaleX),
    y: Math.floor(y * scaleY)
  };
}

/* -------- CANVAS EVENTS -------- */
canvas.onmousedown = e => {
  const { x, y } = getCanvasCoords(e);

  if (tool === 'eyedropper') {
    const pixel = ctx.getImageData(x, y, 1, 1).data;
    const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);
    document.getElementById('colorPicker').value = hex;
    return;
  }

  if (floatingLayer &&
      x >= floatingLayer.x && x <= floatingLayer.x + floatingLayer.w &&
      y >= floatingLayer.y && y <= floatingLayer.y + floatingLayer.h) {
    // handled below
  }

  if (tool === 'fill') {
    renderBaseOnly();
    floodFill(ctx, x, y, colorPicker.value, 64);
    saveState();
    render();
    return;
  }

  if (tool === 'text') {
    if (isEditingText) finishTextEditing();
    textPosition = { x, y };
    textContent = '';
    isEditingText = true;
    startCursorBlink();
    render();
    return;
  }

  // Scale handles
  if (tool === 'select' && selectionRect && floatingLayer && transformMode === 'scale') {
    const tol = 8;
    const { x: sx, y: sy, w, h } = selectionRect;
    if (Math.abs(x - sx) <= tol && Math.abs(y - sy) <= tol) { isResizing = true; resizeHandleType = 'nw'; startX = x; startY = y; return; }
    if (Math.abs(x - (sx + w)) <= tol && Math.abs(y - sy) <= tol) { isResizing = true; resizeHandleType = 'ne'; startX = x; startY = y; return; }
    if (Math.abs(x - sx) <= tol && Math.abs(y - (sy + h)) <= tol) { isResizing = true; resizeHandleType = 'sw'; startX = x; startY = y; return; }
    if (Math.abs(x - (sx + w)) <= tol && Math.abs(y - (sy + h)) <= tol) { isResizing = true; resizeHandleType = 'se'; startX = x; startY = y; return; }
  }

  // Rotate handles
  if (tool === 'select' && selectionRect && floatingLayer && transformMode === 'rotate') {
    const rad = 8;
    const { x: rx, y: ry, w, h } = selectionRect;
    const corners = [{x:rx,y:ry},{x:rx+w,y:ry},{x:rx,y:ry+h},{x:rx+w,y:ry+h}];
    for (const corner of corners) {
      const dx = x - corner.x;
      const dy = y - corner.y;
      if (Math.sqrt(dx*dx + dy*dy) <= rad) {
        isRotating = true;
        const cx = rx + w/2, cy = ry + h/2;
        const angle = Math.atan2(y - cy, x - cx);
        startAngle = angle - floatingLayer.rotation;
        return;
      }
    }
  }

  // Drag floating layer
  if (floatingLayer &&
      x >= floatingLayer.x && x <= floatingLayer.x + floatingLayer.w &&
      y >= floatingLayer.y && y <= floatingLayer.y + floatingLayer.h) {
    isDraggingFloating = true;
    dragOffsetX = x - floatingLayer.x;
    dragOffsetY = y - floatingLayer.y;
    return;
  }

  startX = x;
  startY = y;

  if (tool === 'brush') {
    isDrawing = true;
    wasDragged = false;
    currentBrushPath = [{ x, y }];
  }

  if (tool === 'eraser') {
    isDrawing = true;
    wasDragged = false;
    currentBrushPath = [{ x, y }];
	ctx.save();
	ctx.globalCompositeOperation = 'destination-out';
	ctx.beginPath();
	ctx.arc(x, y, eraserSize / 2, 0, Math.PI * 2);
	ctx.fill();
	ctx.restore();
    eraserCursor.style.width = eraserSize + 'px';
    eraserCursor.style.height = eraserSize + 'px';
	eraserCursor.style.left = (e.clientX) + 'px';
	eraserCursor.style.top = (e.clientY + eraserSize) + 'px';
    eraserCursor.style.display = 'block';
  }

	if (tool === 'rect' || tool === 'ellipse' || tool === 'rectStroke' || tool === 'ellipseStroke') {
		isDrawing = true;
		currentShape = { type: tool, x, y, w: 0, h: 0, color: colorPicker.value };
	}

  if (tool === 'select') {
    isSelecting = true;
    selectionRect = { x, y, w: 0, h: 0 };
    updateSelectionButtons();
  }

  if (tool === 'line') {
    if (lineStart === null) lineStart = { x, y };
    render();
    return;
  }
};

canvas.onmousemove = e => {
  const { x, y } = getCanvasCoords(e);
  mousePos.x = x;
  mousePos.y = y;

  if (isResizing && floatingLayer) {
    const dx = x - startX;
    const dy = y - startY;
    let newW = floatingLayer.w;
    let newH = floatingLayer.h;
    switch (resizeHandleType) {
      case 'nw': newW -= dx; newH -= dy; floatingLayer.x += dx; floatingLayer.y += dy; break;
      case 'ne': newW += dx; newH -= dy; floatingLayer.y += dy; break;
      case 'sw': newW -= dx; newH += dy; floatingLayer.x += dx; break;
      case 'se': newW += dx; newH += dy; break;
    }
    if (newW < 5) newW = 5;
    if (newH < 5) newH = 5;
    floatingLayer.w = newW;
    floatingLayer.h = newH;
    selectionRect.x = floatingLayer.x;
    selectionRect.y = floatingLayer.y;
    selectionRect.w = newW;
    selectionRect.h = newH;
    render();
    startX = x;
    startY = y;
    return;
  }

  if (isRotating && floatingLayer) {
    const { x: rx, y: ry, w, h } = selectionRect;
    const cx = rx + w/2, cy = ry + h/2;
    const angle = Math.atan2(y - cy, x - cx);
    floatingLayer.rotation = angle - startAngle;
    render();
    return;
  }

  if (isDraggingFloating) {
    floatingLayer.x = x - dragOffsetX;
    floatingLayer.y = y - dragOffsetY;
    selectionRect.x = floatingLayer.x;
    selectionRect.y = floatingLayer.y;
    render();
    return;
  }

  if (tool === 'brush' && isDrawing) {
    wasDragged = true;
    currentBrushPath.push({ x, y });
    render();
  }

  if (tool === 'eraser' && isDrawing) {
    const last = currentBrushPath[currentBrushPath.length - 1];
    ctx.save();
    ctx.globalCompositeOperation = 'destination-out';
    ctx.lineWidth = eraserSize;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(last.x, last.y);
    ctx.lineTo(x, y);
    ctx.stroke();
    ctx.restore();
    wasDragged = true;
    currentBrushPath.push({ x, y });
    eraserCursor.style.left = (e.clientX ) + 'px';
    eraserCursor.style.top = (e.clientY + eraserSize) + 'px';
  }

  if (isDrawing && (tool === 'rect' || tool === 'ellipse' || tool === 'rectStroke' || tool === 'ellipseStroke')) {
    currentShape.w = x - startX;
    currentShape.h = y - startY;
    render();
  }

  if (tool === 'select' && isSelecting) {
    selectionRect.w = x - startX;
    selectionRect.h = y - startY;
    render();
  }
};

canvas.onmouseup = () => {
  if (isDraggingFloating) {
    isDraggingFloating = false;
    return;
  }

  if (tool === 'line' && lineStart !== null) {
    const endX = mousePos.x;
    const endY = mousePos.y;
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(lineStart.x, lineStart.y);
    ctx.lineTo(endX, endY);
    ctx.strokeStyle = colorPicker.value;
    ctx.lineWidth = brushSize;
    ctx.stroke();
    ctx.restore();
    saveState();
    lineStart = { x: endX, y: endY };
    render();
    return;
  }

  if (tool === 'eraser' && isDrawing) {
    isDrawing = false;
    saveState();
    currentBrushPath = [];
    eraserCursor.style.display = 'none';
  }


  if (tool === 'brush' && isDrawing) {
    isDrawing = false;
    ctx.save();
    ctx.strokeStyle = colorPicker.value;
    ctx.lineWidth = brushSize;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
  
    if (currentBrushPath.length === 1) {
      // –û–¥–∏–Ω–æ–∫–∏–π –∫–ª—ñ–∫ ‚Äî –º–∞–ª—é—î–º–æ —Ç–æ—á–∫—É
      const pt = currentBrushPath[0];
      ctx.arc(pt.x, pt.y, brushSize / 2, 0, Math.PI * 2);
      ctx.fillStyle = colorPicker.value;
      ctx.fill();
    } else {
      // –ó–≤–∏—á–∞–π–Ω–∏–π —à—Ç—Ä–∏—Ö
      ctx.moveTo(currentBrushPath[0].x, currentBrushPath[0].y);
      for (let i = 1; i < currentBrushPath.length; i++) {
        ctx.lineTo(currentBrushPath[i].x, currentBrushPath[i].y);
      }
      ctx.stroke();
    }
  
    ctx.restore();
    saveState();
    currentBrushPath = [];
  }


  if (isDrawing && (tool === 'rect' || tool === 'ellipse' || tool === 'rectStroke' || tool === 'ellipseStroke')) {
    isDrawing = false;
    drawShape(currentShape, true);
    currentShape = null;
    saveState();
  }

  if (tool === 'select' && isSelecting) {
    isSelecting = false;
    normalizeSelection();
    render();
  }

  if (isResizing) {
    isResizing = false;
    resizeHandleType = null;
    return;
  }

  if (isRotating) {
    isRotating = false;
    return;
  }
};

canvas.ondblclick = () => {
  if (tool === 'line') {
    lineStart = null;
    render();
  } else {
    commitFloatingLayer();
  }
};

// Keyboard for text
window.addEventListener('keydown', (e) => {
  if (!isEditingText) return;
  e.preventDefault();
  if (e.key === 'Enter') {
    finishTextEditing();
  } else if (e.key === 'Backspace') {
    textContent = textContent.slice(0, -1);
    render();
  } else if (e.key.length === 1) {
    textContent += e.key;
    render();
  }
});

/* -------- TEXT CURSOR -------- */
function startCursorBlink() {
  cursorVisible = true;
  if (cursorBlinkInterval) clearInterval(cursorBlinkInterval);
  cursorBlinkInterval = setInterval(() => {
    cursorVisible = !cursorVisible;
    render();
  }, 500);
}
function finishTextEditing() {
  if (textContent.trim() !== '') {
    renderBaseOnly();
    ctx.save();
    ctx.fillStyle = colorPicker.value;
    ctx.font = `${brushSize * 12}px Arial`;
    ctx.fillText(textContent, textPosition.x, textPosition.y);
    ctx.restore();
    saveState();
  }
  isEditingText = false;
  textContent = '';
  textPosition = null;
  if (cursorBlinkInterval) {
    clearInterval(cursorBlinkInterval);
    cursorBlinkInterval = null;
  }
  render();
}

/* -------- FLOATING LAYER -------- */
function commitFloatingLayer() {
  if (!floatingLayer) return;
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = floatingLayer.original.width;
  tempCanvas.height = floatingLayer.original.height;
  const tempCtx = tempCanvas.getContext('2d');
  tempCtx.putImageData(floatingLayer.original, 0, 0);

  const finalCanvas = document.createElement('canvas');
  finalCanvas.width = canvas.width;
  finalCanvas.height = canvas.height;
  const finalCtx = finalCanvas.getContext('2d');
  if (historyIndex >= 0) {
    finalCtx.putImageData(history[historyIndex], 0, 0);
  }

  const { x, y, w, h, rotation } = floatingLayer;
  const cx = x + w/2, cy = y + h/2;
  finalCtx.save();
  finalCtx.translate(cx, cy);
  finalCtx.rotate(rotation);
  finalCtx.drawImage(tempCanvas, -w/2, -h/2, w, h);
  finalCtx.restore();

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(finalCanvas, 0, 0);
  floatingLayer = null;
  selectionRect = null;
  saveState();
  render();
  updateSelectionButtons();
}

function renderBaseOnly() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (historyIndex >= 0) {
    ctx.putImageData(history[historyIndex], 0, 0);
  }
}

/* -------- SELECTION -------- */
function normalizeSelection(){
  if(!selectionRect) return;
  if(selectionRect.w < 0){ selectionRect.x += selectionRect.w; selectionRect.w *= -1; }
  if(selectionRect.h < 0){ selectionRect.y += selectionRect.h; selectionRect.h *= -1; }
  if(selectionRect.w < 5 || selectionRect.h < 5) selectionRect = null;
  updateSelectionButtons();
}
  function createFloatingFromSelection() {
    if (!selectionRect || historyIndex < 0) return null;
  
    normalizeSelection();
    if (!selectionRect || selectionRect.w < 1 || selectionRect.h < 1) return null;
  
    const { x: sx, y: sy, w, h } = selectionRect;
    const src = history[historyIndex];
    const imageData = new ImageData(w, h);
  
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const srcIdx = ((sy + y) * src.width + (sx + x)) * 4;
        const dstIdx = (y * w + x) * 4;
        imageData.data[dstIdx]     = src.data[srcIdx];
        imageData.data[dstIdx + 1] = src.data[srcIdx + 1];
        imageData.data[dstIdx + 2] = src.data[srcIdx + 2];
        imageData.data[dstIdx + 3] = src.data[srcIdx + 3];
      }
    }
  
    // –°—Ç–≤–æ—Ä—é—î–º–æ floating layer
    floatingLayer = {
      x: sx,
      y: sy,
      w: w,
      h: h,
      original: imageData,
      rotation: 0
    };
  
    // –í–∏–¥–∞–ª—è—î–º–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏–π —Ñ—Ä–∞–≥–º–µ–Ω—Ç –∑ –±–∞–∑–æ–≤–æ–≥–æ –ø–æ–ª–æ—Ç–Ω–∞
    renderBaseOnly();
    const clear = ctx.createImageData(w, h);
    ctx.putImageData(clear, sx, sy);
    saveState(); // –∑–±–µ—Ä—ñ–≥–∞—î–º–æ —Å—Ç–∞–Ω –ë–ï–ó –≤–∏–¥—ñ–ª–µ–Ω–æ–≥–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç–∞
  
    return floatingLayer;
  }
/* -------- COPY / PASTE -------- */
function copySelection() {
  if (!selectionRect || historyIndex < 0) return;
  const src = history[historyIndex];
  const { x: sx, y: sy, w, h } = selectionRect;
  clipboardData = new ImageData(w, h);
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const srcIdx = ((sy + y) * src.width + (sx + x)) * 4;
      const dstIdx = (y * w + x) * 4;
      clipboardData.data[dstIdx]     = src.data[srcIdx];
      clipboardData.data[dstIdx + 1] = src.data[srcIdx + 1];
      clipboardData.data[dstIdx + 2] = src.data[srcIdx + 2];
      clipboardData.data[dstIdx + 3] = src.data[srcIdx + 3];
      if (src.data[srcIdx] === 255 && src.data[srcIdx + 1] === 255 && src.data[srcIdx + 2] === 255 && src.data[srcIdx + 3] === 255) {
        clipboardData.data[dstIdx + 3] = 0;
      }
    }
  }
  updateSelectionButtons();
  updatePasteButtonVisibility();
}

function pasteSelection(){
  if (!clipboardData) return;
  originalClipboard = clipboardData;
  floatingLayer = {
    x: 20, y: 20,
    w: clipboardData.width,
    h: clipboardData.height,
    original: clipboardData,
    rotation: 0
  };
  selectionRect = { x: 20, y: 20, w: clipboardData.width, h: clipboardData.height };
  render();
  updateSelectionButtons();
}

function deleteSelection() {
  if (floatingLayer) {
    floatingLayer = null;
    selectionRect = null;
    render();
    return;
  }
  if (selectionRect) {
    renderBaseOnly();
    const { x, y, w, h } = selectionRect;
    const clear = ctx.createImageData(w, h);
    ctx.putImageData(clear, x, y);
    saveState();
    selectionRect = null;
    render();
  }
  updateSelectionButtons();
}

function drawShape(shape, commit = false) {
  if (!shape) return;
  if (!commit) ctx.save();
  console.log("Shape=",shape)
  const color = shape.color;

  if (shape.type === 'rect') {
    // –ó–∞–ø–æ–≤–Ω–µ–Ω–∏–π –ø—Ä—è–º–æ–∫—É—Ç–Ω–∏–∫
    ctx.fillStyle = color;
    ctx.fillRect(shape.x, shape.y, shape.w, shape.h);
    ctx.strokeStyle = color; // ‚Üê –∫–æ–Ω—Ç—É—Ä —Ç–æ–≥–æ —Å–∞–º–æ–≥–æ –∫–æ–ª—å–æ—Ä—É
    ctx.strokeRect(shape.x, shape.y, shape.w, shape.h);
  } else if (shape.type === 'rectStroke') {
    // –õ–∏—à–µ –∫–æ–Ω—Ç—É—Ä
    console.log("rectStroke")
    ctx.strokeStyle = color;
    ctx.lineWidth = brushSize;
    ctx.strokeRect(shape.x, shape.y, shape.w, shape.h);
  } else if (shape.type === 'ellipse') {
    // –ó–∞–ø–æ–≤–Ω–µ–Ω–∏–π –µ–ª—ñ–ø—Å
    ctx.beginPath();
    ctx.ellipse(
      shape.x + shape.w / 2,
      shape.y + shape.h / 2,
      Math.abs(shape.w / 2),
      Math.abs(shape.h / 2),
      0, 0, 2 * Math.PI
    );
    ctx.fillStyle = color;
    ctx.fill();
    ctx.strokeStyle = color; // ‚Üê –∫–æ–Ω—Ç—É—Ä —Ç–æ–≥–æ —Å–∞–º–æ–≥–æ –∫–æ–ª—å–æ—Ä—É
    ctx.stroke();
  } else if (shape.type === 'ellipseStroke') {
    // –õ–∏—à–µ –∫–æ–Ω—Ç—É—Ä
    ctx.beginPath();
    ctx.ellipse(
      shape.x + shape.w / 2,
      shape.y + shape.h / 2,
      Math.abs(shape.w / 2),
      Math.abs(shape.h / 2),
      0, 0, 2 * Math.PI
    );
    ctx.strokeStyle = color;
    ctx.lineWidth = brushSize;
    ctx.stroke();
  }

  if (!commit) ctx.restore();
}

/* -------- RENDER -------- */
function render(){
  if ((tool === 'brush' || tool === 'eraser') && isDrawing) {
    // only overlay
  } else {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (historyIndex >= 0) {
      ctx.putImageData(history[historyIndex], 0, 0);
    }
  }

  if (floatingLayer) {
    const { x, y, w, h, original, rotation } = floatingLayer;
    const cx = x + w/2, cy = y + h/2;
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = original.width;
    tempCanvas.height = original.height;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.putImageData(original, 0, 0);
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rotation);
    ctx.drawImage(tempCanvas, -w/2, -h/2, w, h);
    ctx.restore();
  }

  if (currentShape) drawShape(currentShape, false);

  if (currentBrushPath.length > 0) {
    if (tool === 'brush' && isDrawing) {
      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = colorPicker.value;
      ctx.lineWidth = brushSize;
      ctx.beginPath();
      ctx.moveTo(currentBrushPath[0].x, currentBrushPath[0].y);
      for (let i = 1; i < currentBrushPath.length; i++) {
        ctx.lineTo(currentBrushPath[i].x, currentBrushPath[i].y);
      }
      ctx.stroke();
      ctx.restore();
    }
  }

  if (tool === 'line' && lineStart !== null) {
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(lineStart.x, lineStart.y);
    ctx.lineTo(mousePos.x, mousePos.y);
    ctx.strokeStyle = colorPicker.value;
    ctx.lineWidth = brushSize;
    ctx.globalAlpha = 0.6;
    ctx.stroke();
    ctx.restore();
  }

  if (isEditingText && textPosition) {
    ctx.save();
    ctx.fillStyle = colorPicker.value;
    ctx.font = `${brushSize * 12}px Arial`;
    ctx.fillText(textContent, textPosition.x, textPosition.y);
    if (cursorVisible) {
      const tw = ctx.measureText(textContent).width;
      const cx = textPosition.x + tw;
      const cy = textPosition.y;
      const ch = brushSize * 12;
      ctx.strokeStyle = colorPicker.value;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cx, cy - ch + 4);
      ctx.lineTo(cx, cy + 4);
      ctx.stroke();
    }
    ctx.restore();
  }

  drawSelection();
}

function drawSelection(){
  if (!selectionRect) return;
  const { x, y, w, h } = selectionRect;
  ctx.save();
  ctx.setLineDash([6, 4]);
  ctx.lineDashOffset = -dashOffset;
  ctx.strokeStyle = "#000";
  ctx.strokeRect(x, y, w, h);

const corners = [
  { x: x, y: y },
  { x: x + w, y: y },
  { x: x, y: y + h },
  { x: x + w, y: y + h }
];
  if (transformMode === 'scale') {
    const size = 8;
    ctx.fillStyle = "#00aaff";
    corners.forEach(pt => {
      ctx.fillRect(pt.x - size/2, pt.y - size/2, size, size);
    });
  } else if (transformMode === 'rotate') {
    const radius = 5;
    ctx.fillStyle = "#ff0000";
    corners.forEach(pt => {
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, radius, 0, Math.PI*2);
      ctx.fill();
    });
  }
  ctx.restore();
}

/* -------- ANIMATION -------- */
function animateAnts(){
  dashOffset++;
  render();
  requestAnimationFrame(animateAnts);
}
//
function shrinkIMG() {
  const w = canvas.width;
  const h = canvas.height;

  const newW = Math.max(1, Math.floor(w * 0.5));
  const newH = Math.max(1, Math.floor(h * 0.5));

  // üëâ —Ç–∏–º—á–∞—Å–æ–≤–∏–π canvas –¥–ª—è –∫–æ–ø—ñ—ó
  const tmpCanvas = document.createElement('canvas');
  tmpCanvas.width = w;
  tmpCanvas.height = h;

  const tmpCtx = tmpCanvas.getContext('2d');
  tmpCtx.drawImage(canvas, 0, 0);

  // üëâ –∑–º—ñ–Ω—é—î–º–æ —Ä–æ–∑–º—ñ—Ä –æ—Å–Ω–æ–≤–Ω–æ–≥–æ canvas
  canvas.width = newW;
  canvas.height = newH;

  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  // nearest-neighbor (–±–µ–∑ —Ä–æ–∑–º–∏—Ç—Ç—è)
  ctx.imageSmoothingEnabled = false;

  // üëâ –º–∞—Å—à—Ç–∞–±—É–≤–∞–Ω–Ω—è —á–µ—Ä–µ–∑ drawImage
  ctx.drawImage(tmpCanvas, 0, 0, w, h, 0, 0, newW, newH);
  canvas.style.filter = "contrast(1.15)";


  // --- –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ ---
  const container = document.getElementById('canvasContainer');
  container.style.width = newW + 'px';
  container.style.height = newH + 'px';

  // --- handle resize ---
  const handle = document.getElementById('canvasResizeHandle');
  const offset = 8;
  handle.style.transform = `translate(${offset}px, ${offset}px) scale(${1 / currentZoom})`;

  // --- —Å–∫–∏–¥–∞–Ω–Ω—è –≤–∏–¥—ñ–ª–µ–Ω–Ω—è ---
  selectionRect = null;
  floatingLayer = null;
  updateSelectionButtons();

  // --- –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è ---
  saveState();
  render();
}

/* -------- ROTATE IMAGE CLOCKWISE -------- */
function rotateCW() {
  console.log("rotateCW")	
  const angleRad = Math.PI / 4; // 45¬∞
  const w = canvas.width;
  const h = canvas.height;

  // 1. –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ—Ç–æ—á–Ω–∏–π –≤–º—ñ—Å—Ç
  const imageData = ctx.getImageData(0, 0, w, h);

  // 2. –¢–∏–º—á–∞—Å–æ–≤–∏–π canvas –¥–ª—è –ø–æ–≤–æ—Ä–æ—Ç—É
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = w;
  tempCanvas.height = h;
  const tempCtx = tempCanvas.getContext('2d', { willReadFrequently: true });
  tempCtx.putImageData(imageData, 0, 0);

  // 3. –û–±—á–∏—Å–ª—é—î–º–æ —Ä–æ–∑–º—ñ—Ä canvas, –¥–æ—Å—Ç–∞—Ç–Ω—ñ–π –¥–ª—è –ø–æ–≤–æ—Ä–æ—Ç—É –±–µ–∑ –æ–±—Ä—ñ–∑–∞–Ω–Ω—è
  const cos = Math.abs(Math.cos(angleRad));
  const sin = Math.abs(Math.sin(angleRad));
  const newW = Math.ceil(w * cos + h * sin);
  const newH = Math.ceil(w * sin + h * cos);

  const rotatedCanvas = document.createElement('canvas');
  rotatedCanvas.width = newW;
  rotatedCanvas.height = newH;
  const rotCtx = rotatedCanvas.getContext('2d', { willReadFrequently: true });

  // 4. –ú–∞–ª—é—î–º–æ –æ–±–µ—Ä–Ω–µ–Ω–µ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –ø–æ —Ü–µ–Ω—Ç—Ä—É
  rotCtx.clearRect(0, 0, newW, newH);
  rotCtx.save();
  rotCtx.translate(newW / 2, newH / 2);
  rotCtx.rotate(angleRad);
  rotCtx.drawImage(tempCanvas, -w / 2, -h / 2);
  rotCtx.restore();

  // 5. –ó–Ω–∞—Ö–æ–¥–∏–º–æ bounding box –Ω–µ–ø—Ä–æ–∑–æ—Ä–∏—Ö –ø—ñ–∫—Å–µ–ª—ñ–≤
  const rotData = rotCtx.getImageData(0, 0, newW, newH);
  let minX = newW, minY = newH, maxX = -1, maxY = -1;

  for (let y = 0; y < newH; y++) {
    for (let x = 0; x < newW; x++) {
      const i = (y * newW + x) * 4;
      if (rotData.data[i + 3] > 0) { // alpha > 0
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }
    }
  }

  // –Ø–∫—â–æ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è –ø–æ–≤–Ω—ñ—Å—Ç—é –ø—Ä–æ–∑–æ—Ä–µ ‚Äî –Ω—ñ—á–æ–≥–æ –Ω–µ —Ä–æ–±–∏–º–æ
  if (maxX === -1) return;

  const cropW = maxX - minX + 1;
  const cropH = maxY - minY + 1;

  // 6. –û–±—Ä—ñ–∑–∞—î–º–æ
  const croppedData = rotCtx.getImageData(minX, minY, cropW, cropH);

  // 7. –û–Ω–æ–≤–ª—é—î–º–æ –æ—Å–Ω–æ–≤–Ω–∏–π canvas
  canvas.width = cropW;
  canvas.height = cropH;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.imageSmoothingEnabled = false;
  ctx.putImageData(croppedData, 0, 0);

  // 8. –û–Ω–æ–≤–ª—é—î–º–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
  const container = document.getElementById('canvasContainer');
  container.style.width = cropW + 'px';
  container.style.height = cropH + 'px';

  // 9. –û–Ω–æ–≤–ª—é—î–º–æ handle resize
  const handle = document.getElementById('canvasResizeHandle');
  const offset = 8;
  handle.style.transform = `translate(${offset}px, ${offset}px) scale(${1 / currentZoom})`;

  // 10. –°–∫–∏–¥–∞—î–º–æ –≤–∏–¥—ñ–ª–µ–Ω–Ω—è
  selectionRect = null;
  floatingLayer = null;
  updateSelectionButtons();

  // 11. –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Å—Ç–∞–Ω
  saveState();
  render();
}

async function saveToFS(path) {
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = canvas.width;
    exportCanvas.height = canvas.height;

    const exportCtx = exportCanvas.getContext('2d');
    exportCtx.putImageData(history[historyIndex], 0, 0);

    const dataUrl = exportCanvas.toDataURL('image/png');

    await jsfs.write(path, dataUrl);

}

/* -------- FILE I/O -------- */
function openImage() {
  document.getElementById('fileInput').click();
}
document.getElementById('fileInput').addEventListener('change', (e) => {
	const file = e.target.files[0];
	if (!file) return;
	const reader = new FileReader();
	reader.onload = (event) => {
		const img = new Image();
		img.onload = () => {
			// –ó–º—ñ–Ω—é—î–º–æ —Ä–æ–∑–º—ñ—Ä canvas –ø—ñ–¥ –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è
			canvas.width = img.width;
			canvas.height = img.height;

			// –û–Ω–æ–≤–ª—é—î–º–æ —Ä–æ–∑–º—ñ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
			const canvasContainer = document.getElementById('canvasContainer');
			canvasContainer.style.width = canvas.width + 'px';
			canvasContainer.style.height = canvas.height + 'px';

			ctx.lineCap = 'round';
			ctx.lineJoin = 'round';
			ctx.imageSmoothingEnabled = false;

			ctx.clearRect(0, 0, canvas.width, canvas.height);
			ctx.drawImage(img, 0, 0);

			saveState();
			selectionRect = null;
			floatingLayer = null;
			applyZoom(currentZoom); // –∞–±–æ applyZoom(1) –¥–ª—è —Å–∫–∏–¥–∞–Ω–Ω—è
			render();
		};
		img.src = event.target.result;
	};
	reader.readAsDataURL(file);
});

function saveImage() {
  const exportCanvas = document.createElement('canvas');
  exportCanvas.width = canvas.width;
  exportCanvas.height = canvas.height;
  const exportCtx = exportCanvas.getContext('2d');
  if (historyIndex >= 0) {
    exportCtx.putImageData(history[historyIndex], 0, 0);
  } else {
    exportCtx.drawImage(canvas, 0, 0);
  }
  const link = document.createElement('a');
  link.download = 'canvas-image.png';
  link.href = exportCanvas.toDataURL('image/png');
  link.click();
}

function mirrorFloatingLayer(vertical = false, horizontal = false) {
  if (!floatingLayer) return;
  const { original } = floatingLayer;
  const w = original.width;
  const h = original.height;
  const mirrored = new ImageData(w, h);
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const srcX = horizontal ? w - 1 - x : x;
      const srcY = vertical ? h - 1 - y : y;
      const srcIdx = (srcY * w + srcX) * 4;
      const dstIdx = (y * w + x) * 4;
      mirrored.data[dstIdx]     = original.data[srcIdx];
      mirrored.data[dstIdx + 1] = original.data[srcIdx + 1];
      mirrored.data[dstIdx + 2] = original.data[srcIdx + 2];
      mirrored.data[dstIdx + 3] = original.data[srcIdx + 3];
    }
  }
  floatingLayer.original = mirrored;
  render();
}

/* -------- BUTTON HANDLERS -------- */
document.getElementById('openBtn').onclick = openImage;
document.getElementById('saveBtn').onclick = saveImage;

document.querySelector('.brush-controls').style.display = 'flex';
document.querySelector('.eraser-controls').style.display = 'none';

canvas.tabIndex = 0;
canvas.focus();
canvas.addEventListener('click', () => canvas.focus());

/* -------- CANVAS RESIZE HANDLE -------- */
resizeHandle.addEventListener('mousedown', (e) => {
  e.preventDefault();
  isResizingCanvas = true;
  startWidth = canvas.width;
  startHeight = canvas.height;
  startClientX = e.clientX;
  startClientY = e.clientY;
  canvas.style.pointerEvents = 'none';
});

// –£ –æ–±—Ä–æ–±–Ω–∏–∫—É mousemove –¥–ª—è –∑–º—ñ–Ω–∏ —Ä–æ–∑–º—ñ—Ä—É:
window.addEventListener('mousemove', (e) => {
  if (!isResizingCanvas) return;
  const dx = e.clientX - startClientX;
  const dy = e.clientY - startClientY;
  let newWidth = Math.max(32, startWidth + dx);
  let newHeight = Math.max(32, startHeight + dy);

  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

  canvas.width = newWidth;
  canvas.height = newHeight;
 // –û–Ω–æ–≤–ª—é—î–º–æ —Ä–æ–∑–º—ñ—Ä –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
  const canvasContainer = document.getElementById('canvasContainer');
  canvasContainer.style.width = canvas.width + 'px';
  canvasContainer.style.height = canvas.height + 'px';
  // üîë –í—ñ–¥–Ω–æ–≤–ª—é—î–º–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç—É!
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.imageSmoothingEnabled = false;

  ctx.putImageData(imageData, 0, 0);

  // –û–Ω–æ–≤–ª—é—î–º–æ –ø–æ—á–∞—Ç–∫–æ–≤—ñ –∑–Ω–∞—á–µ–Ω–Ω—è
  startClientX = e.clientX;
  startClientY = e.clientY;
  startWidth = newWidth;
  startHeight = newHeight;

  saveState();
  render();
});

window.addEventListener('mouseup', () => {
  if (isResizingCanvas) {
    isResizingCanvas = false;
    canvas.style.pointerEvents = 'auto';
  }
});

});
/*
					<button id="modal-cancel-btn" class="btn btn-cancel">–°–∫–∞—Å—É–≤–∞—Ç–∏</button>
					<button id="modal-no-btn" class="btn btn-cancel">–ù—ñ</button>
					<button id="modal-ok-btn" class="btn btn-ok">–¢–∞–∫</button>
*/

// –∫–µ—Ä—É–≤–∞–Ω–Ω—è –º–æ–¥–∞–ª—å–Ω–∏–º –≤—ñ–∫–Ω–æ–º –¥–ª—è message/confirm/input
const ModalUI = {
            container: document.getElementById('modal-container'),
            title: document.getElementById('modal-title'),
            text: document.getElementById('modal-text'),
            inputWrapper: document.getElementById('modal-input-wrapper'),
            inputField: document.getElementById('modal-input-field'),
            okBtn: document.getElementById('modal-ok-btn'),
            cancelBtn: document.getElementById('modal-cancel-btn'),

            show(title, text, type) {
                return new Promise((resolve) => {
                    // –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∫–æ–Ω—Ç–µ–Ω—Ç—É
                    this.title.innerText = title;
                    this.text.innerText = text;
                    this.inputField.value = '';
                    
                    // –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –≤–∏–¥–∏–º–æ—Å—Ç—ñ –µ–ª–µ–º–µ–Ω—Ç—ñ–≤
                    this.inputWrapper.style.display = (type === 'input') ? 'block' : 'none';
                    this.cancelBtn.style.display = (type === 'message') ? 'none' : 'inline-block';
                    this.container.style.display = 'flex';

                    // –û–±—Ä–æ–±–∫–∞ –∫–Ω–æ–ø–æ–∫
                    const cleanup = () => {
                        this.container.style.display = 'none';
                    };

                    this.okBtn.onclick = () => {
                        cleanup();
                        resolve(type === 'input' ? this.inputField.value : true);
                    };

                    this.cancelBtn.onclick = () => {
                        cleanup();
                        resolve(type === 'input' ? null : false);
                    };

                    // –§–æ–∫—É—Å –Ω–∞ –ø–æ–ª—ñ –≤–≤–µ–¥–µ–Ω–Ω—è, —è–∫—â–æ —Ü–µ input
                    if (type === 'input') {
                        setTimeout(() => this.inputField.focus(), 100);
                    }
                });
            }
        };
        // –≤–∏–≤–µ–¥–µ–Ω–Ω—è —Ç–∞ –≤–≤–µ–¥–µ–Ω–Ω—è
        async function message(title, text) {
			document.getElementById('modal-container').style.display = 'none'
            return await ModalUI.show(title, text, 'message');
            
        }

        async function askConfirm(title, text) {
            return await ModalUI.show(title, text, 'confirm');
        }

        async function input(title, text) {
            return await ModalUI.show(title, text, 'input');
        }


		</script>
	</body>
</html>
